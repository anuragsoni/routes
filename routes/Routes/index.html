<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Routes (routes.Routes)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0-97-ga52dd8e"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">routes</a> &#x00BB; Routes</nav><header class="odoc-preamble"><h1>Module <code><span>Routes</span></code></h1><p>Typed routing for OCaml. <code>Routes</code> provides combinators for adding typed routing to OCaml applications. The core library will be independent of any particular web framework or runtime.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-path"><a href="#type-path" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'b) path</span></span></code></div><div class="spec-doc"><p><code>path</code> represents a sequence of path parameter patterns that are expected in a route.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-route"><a href="#type-route" class="anchor"></a><code><span><span class="keyword">type</span> <span>'b route</span></span></code></div><div class="spec-doc"><p><code>route</code> is a combination of a path sequence, with a function that will be called on a successful match. When a path sequence matches, the patterns that are extracted are forwarded to said function with the types that the user defined. Note that because of <a href="https://caml.inria.fr/pub/docs/manual-ocaml/polymorphism.html#ss:valuerestriction">value restriction</a>, the route definitions will be assigned a weak type by the compiler. This causes problems if one intends to re-use the same route definition in multiple contexts, like using a single definition for both matching a target url, and serializing to use in a client call. To avoid such problems one can use eta-expansion (i.e. add an explicit argument to the route definition).</p><p>Example:</p><pre class="language-ocaml"><code>let route () =
  Routes.(
    (s &quot;foo&quot; / str / int /? nil)
    @--&gt; fun (a : string) (b : int) -&gt; Printf.sprintf &quot;%s %d&quot; a b)
;;</code></pre></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-router"><a href="#type-router" class="anchor"></a><code><span><span class="keyword">type</span> <span>'b router</span></span></code></div><div class="spec-doc"><p><code>router</code> is a collection of multiple routes. It transforms a list of routes into a trie like structure, that is then used for matching an input target url.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Parts"><a href="#module-Parts" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Parts/index.html">Parts</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-int"><a href="#val-int" class="anchor"></a><code><span><span class="keyword">val</span> int : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-path">path</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-path">path</a></span></span></code></div><div class="spec-doc"><p><code>int</code> matches a path segment if it can be successfully coerced into an integer.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-int32"><a href="#val-int32" class="anchor"></a><code><span><span class="keyword">val</span> int32 : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-path">path</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>int32 <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-path">path</a></span></span></code></div><div class="spec-doc"><p><code>int32</code> matches a path segment if it can be successfully coerced into a 32 bit integer.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-int64"><a href="#val-int64" class="anchor"></a><code><span><span class="keyword">val</span> int64 : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-path">path</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>int64 <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-path">path</a></span></span></code></div><div class="spec-doc"><p><code>int64</code> matches a path segment if it can be successfully coerced into a 64 bit integer.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-str"><a href="#val-str" class="anchor"></a><code><span><span class="keyword">val</span> str : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-path">path</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>string <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-path">path</a></span></span></code></div><div class="spec-doc"><p><code>str</code> matches any path segment and forwards it as a string.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-bool"><a href="#val-bool" class="anchor"></a><code><span><span class="keyword">val</span> bool : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-path">path</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>bool <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-path">path</a></span></span></code></div><div class="spec-doc"><p><code>bool</code> matches a path segment if it can be successfully coerced into a boolean.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-s"><a href="#val-s" class="anchor"></a><code><span><span class="keyword">val</span> s : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-path">path</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-path">path</a></span></span></code></div><div class="spec-doc"><p><code>s word</code> matches a path segment if it exactly matches <code>word</code>. The matched path param is then discarded.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-wildcard"><a href="#val-wildcard" class="anchor"></a><code><span><span class="keyword">val</span> wildcard : <span><span>(<span><a href="Parts/index.html#type-t">Parts.t</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>, <span class="type-var">'a</span>)</span> <a href="#type-path">path</a></span></span></code></div><div class="spec-doc"><p><code>wildcard</code> matches all remaining path segments as a string.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-nil"><a href="#val-nil" class="anchor"></a><code><span><span class="keyword">val</span> nil : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span> <a href="#type-path">path</a></span></span></code></div><div class="spec-doc"><p><code>nil</code> is used to end a sequence of path parameters. It can also be used to represent an empty route that can match &quot;/&quot; or &quot;&quot;.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pattern"><a href="#val-pattern" class="anchor"></a><code><span><span class="keyword">val</span> pattern : 
  <span><span>(<span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> string)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>string <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-path">path</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-path">path</a></span></span></code></div><div class="spec-doc"><p><code>pattern</code> accepts two functions, one for converting a user provided type to a string representation, and another to potentially convert a string to the said type. With these two functions, it creates a pattern that can be used for matching a path segment. This is useful when there is a need for types that aren't provided out of the box by the library. It also accepts a string label that will be used when pretty printing the route pattern. it is recommended to use a string value starting with `:` character for the label, example: ':shape', ':float' etc</p><p>Example:</p><pre class="language-ocaml"><code>type shape =
  | Square
  | Circle

let shape_of_string = function
  | &quot;square&quot; -&gt; Some Square
  | &quot;circle&quot; -&gt; Some Circle
  | _ -&gt; None
;;

let shape_to_string = function
  | Square -&gt; &quot;square&quot;
  | Circle -&gt; &quot;circle&quot;
;;

let shape = Routes.pattern shape_to_string shape_of_string &quot;:shape&quot;

(* Now the shape pattern can be used just like any of the built in patterns like
   int, bool etc *)
let route () = s &quot;shape&quot; / shape / s &quot;create&quot; /? nil</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-custom"><a href="#val-custom" class="anchor"></a><code><span><span class="keyword">val</span> custom : 
  <span>serialize:<span>(<span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> string)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>parse:<span>(<span>string <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>label:string <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-path">path</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-path">path</a></span></span></code></div><div class="spec-doc"><p><code>custom</code> is a labelled alternative to <code>pattern</code>.</p><p>Example:</p><pre class="language-ocaml"><code>module Shape = struct
  type t =
    | Square
    | Circle

  let parse = function
    | &quot;square&quot; -&gt; Some Square
    | &quot;circle&quot; -&gt; Some Circle
    | _ -&gt; None
  ;;

  let serialize = function
    | Square -&gt; &quot;square&quot;
    | Circle -&gt; &quot;circle&quot;
  ;;

  let p r = Routes.custom ~serialize ~parse ~label:&quot;:shape&quot; r
end

(* Now the shape pattern can be used just like any of the built in patterns like
   int, bool etc *)
let route () = s &quot;shape&quot; / Shape.p / s &quot;create&quot; /? nil</code></pre><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.8.1</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(/)"><a href="#val-(/)" class="anchor"></a><code><span><span class="keyword">val</span> (/) : <span><span>(<span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-path">path</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'d</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-path">path</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'d</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span></span></code></div><div class="spec-doc"><p><code>l / r</code> joins two path match patterns <code>l</code> and <code>r</code> into a pattern sequence, parse l followed by parse r. Example: If we want to define a route that matches a string followd by a constant &quot;foo&quot; and then an integer, we'd use the <code>/</code> operator like below:</p><pre class="language-ocaml"><code>let route () = Routes.(str / s &quot;foo&quot; / int /? nil)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(/~)"><a href="#val-(/~)" class="anchor"></a><code><span><span class="keyword">val</span> (/~) : <span><span>(<span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-path">path</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <a href="#type-path">path</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-path">path</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <a href="#type-path">path</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(/?)"><a href="#val-(/?)" class="anchor"></a><code><span><span class="keyword">val</span> (/?) : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'b</span>, <span class="type-var">'c</span>)</span> <a href="#type-path">path</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'b</span>, <span class="type-var">'c</span>)</span> <a href="#type-path">path</a></span></span></code></div><div class="spec-doc"><p><code>l /? r</code> is used to express the sequence of, parse l followed by parse r and then stop parsing. This is used at the end of the route pattern to define how a route should end. The right hand parameter <code>r</code> should be a pattern definition that cannot be used in further chains joined by <code>/</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(@--&gt;)"><a href="#val-(@--&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (@--&gt;) : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-path">path</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-route">route</a></span></span></code></div><div class="spec-doc"><p><code>r @--&gt; h</code> is used to connect a route pattern <code>r</code> to a function <code>h</code> that gets called if this pattern is successfully matched.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-route"><a href="#val-route" class="anchor"></a><code><span><span class="keyword">val</span> route : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-path">path</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-route">route</a></span></span></code></div><div class="spec-doc"><p><code>route r h</code> is the same as <code>r @--&gt; h</code>. It is used to connect a route pattern <code>r</code> to a function <code>h</code> that gets called if the pattern is a successfully matched.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.0.0</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-one_of"><a href="#val-one_of" class="anchor"></a><code><span><span class="keyword">val</span> one_of : <span><span><span><span class="type-var">'b</span> <a href="#type-route">route</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-router">router</a></span></span></code></div><div class="spec-doc"><p><code>one_of</code> accepts a list of tuples comprised of route definitions of type <code>'b route</code> where 'b is the type that a successful route match will return.</p><p>It transforms the input list of routes into a trie like structure that can later be used to perform route matches.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-route">route</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-route">route</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-match_result"><a href="#type-match_result" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a match_result</span></span><span> = </span></code><ol><li id="type-match_result.FullMatch" class="def variant constructor anchored"><a href="#type-match_result.FullMatch" class="anchor"></a><code><span>| </span><span><span class="constructor">FullMatch</span> <span class="keyword">of</span> <span class="type-var">'a</span></span></code></li><li id="type-match_result.MatchWithTrailingSlash" class="def variant constructor anchored"><a href="#type-match_result.MatchWithTrailingSlash" class="anchor"></a><code><span>| </span><span><span class="constructor">MatchWithTrailingSlash</span> <span class="keyword">of</span> <span class="type-var">'a</span></span></code></li><li id="type-match_result.NoMatch" class="def variant constructor anchored"><a href="#type-match_result.NoMatch" class="anchor"></a><code><span>| </span><span><span class="constructor">NoMatch</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-match'"><a href="#val-match'" class="anchor"></a><code><span><span class="keyword">val</span> match' : <span><span><span class="type-var">'a</span> <a href="#type-router">router</a></span> <span class="arrow">&#45;&gt;</span></span> <span>target:string <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-match_result">match_result</a></span></span></code></div><div class="spec-doc"><p><code>match'</code> accepts a router and the target url to match.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ksprintf"><a href="#val-ksprintf" class="anchor"></a><code><span><span class="keyword">val</span> ksprintf : <span><span>(<span>string <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-path">path</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>ksprintf</code> takes a route pattern as an input and applies a continuation to the result of formatting the pattern into a URI path.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sprintf"><a href="#val-sprintf" class="anchor"></a><code><span><span class="keyword">val</span> sprintf : <span><span><span>(<span class="type-var">'a</span>, string)</span> <a href="#type-path">path</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>sprintf</code> takes a route pattern as an input, and returns a string with the result of formatting the pattern into a URI path.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_target"><a href="#val-pp_target" class="anchor"></a><code><span><span class="keyword">val</span> pp_target : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-path">path</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>pp_target</code> can be used to pretty-print a sequence of path params. This can be useful to get a human readable output that indicates the kind of pattern that a route will match. When creating a custom pattern matcher using <code>pattern</code>, a string label needs to be provided. This label is used by <code>pp_target</code> when preparing the pretty-print output. Example:</p><pre class="language-ocaml"><code>let r () = Routes.(s &quot;foo&quot; / int / s &quot;add&quot; / bool);;
Format.asprintf &quot;%a&quot; Routes.pp_target r;;
-: &quot;foo/:int/add/:bool&quot;</code></pre><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.8.0</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_route"><a href="#val-pp_route" class="anchor"></a><code><span><span class="keyword">val</span> pp_route : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-route">route</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>pp_route</code> is similar to <code>pp_target</code>, except it takes a route (combination of path sequence and a handler) as input, instead of just a path sequence.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-string_of_path"><a href="#val-string_of_path" class="anchor"></a><code><span><span class="keyword">val</span> string_of_path : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-path">path</a></span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>string_of_path</code> converts a sequence of path params to a human readable string that indicates the kind of pattern that a route will match. When creating a custom pattern matcher using <code>pattern</code>, a string label needs to be provided. This label is used by <code>string_of_path</code> when preparing the pretty-print output.</p><p>Example:</p><pre class="language-ocaml"><code>let r () = Routes.(s &quot;foo&quot; / int / s &quot;add&quot; / bool);;
Routes.path_to_string r;;
-: &quot;foo/:int/add/:bool&quot;</code></pre><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.0.0</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-string_of_route"><a href="#val-string_of_route" class="anchor"></a><code><span><span class="keyword">val</span> string_of_route : <span><span><span class="type-var">'a</span> <a href="#type-route">route</a></span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>string_of_route</code> is similar to <code>string_of_path</code>, except it takes a route (combination of path sequence and a handler) as input, instead of just a path sequence.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 2.0.0</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_route"><a href="#val-add_route" class="anchor"></a><code><span><span class="keyword">val</span> add_route : <span><span><span class="type-var">'b</span> <a href="#type-route">route</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-router">router</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-router">router</a></span></span></code></div><div class="spec-doc"><p><code>add_route</code> takes a route and a router as input, and returns a new router which contains the route provided as input.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.7.3</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-union"><a href="#val-union" class="anchor"></a><code><span><span class="keyword">val</span> union : <span><span><span class="type-var">'a</span> <a href="#type-router">router</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-router">router</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-router">router</a></span></span></code></div><div class="spec-doc"><p><code>union</code> performs a left-biased merge of two routers.</p></div></div></div></body></html>