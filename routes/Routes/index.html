<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Routes (routes.Routes)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">routes</a> &#x00BB; Routes</nav><h1>Module <code>Routes</code></h1><p>Typed routing for OCaml.</p><p><code>Routes</code> provides combinators for adding typed routing to OCaml applications. The core library will be independent of any particular web framework or runtime. It uses continuations in an approach outlined by the following talk by Daniel Patterson: <a href="https://dbp.io/talks/2016/fn-continuations-haskell-meetup.pdf">Typed routing with continuations</a></p></header><dl><dt class="spec module" id="module-RouterState"><a href="#module-RouterState" class="anchor"></a><code><span class="keyword">module</span> <a href="RouterState/index.html">RouterState</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>state</code> is the state that is threaded through the router during parsing.</p></dd></dl><dl><dt class="spec type" id="type-route"><a href="#type-route" class="anchor"></a><code><span class="keyword">type</span> ('req, 'res, 'meth) route</code><code> = (<span class="type-var">'req</span>, <span class="type-var">'meth</span>) <a href="RouterState/index.html#type-state">RouterState.state</a> <span>&#45;&gt;</span> <span class="type-var">'res</span> option</code></dt></dl><dl><dt class="spec value" id="val-s"><a href="#val-s" class="anchor"></a><code><span class="keyword">val</span> s : string <span>&#45;&gt;</span> (<span class="type-var">'req</span>, <span class="type-var">'meth</span>) <a href="RouterState/index.html#type-state">RouterState.state</a> <span>&#45;&gt;</span> ((<span class="type-var">'req</span>, <span class="type-var">'meth</span>) <a href="RouterState/index.html#type-state">RouterState.state</a> * (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)) option</code></dt><dd><p><code>s str</code> does an exact match on the input string. It consumes and discards the string and as a result the handler doesn't need to work on the parsed string. If there are no paths left to match on given URL, or the match failes, the whole route matching fails.</p></dd></dl><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : (<span class="type-var">'req</span>, <span class="type-var">'meth</span>) <a href="RouterState/index.html#type-state">RouterState.state</a> <span>&#45;&gt;</span> ((<span class="type-var">'req</span>, <span class="type-var">'meth</span>) <a href="RouterState/index.html#type-state">RouterState.state</a> * (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)) option</code></dt><dd><p><code>empty</code> confirms that there is nothing left to consume in the URL's paths.</p></dd></dl><dl><dt class="spec value" id="val-anything"><a href="#val-anything" class="anchor"></a><code><span class="keyword">val</span> anything : (<span class="type-var">'req</span>, <span class="type-var">'meth</span>) <a href="RouterState/index.html#type-state">RouterState.state</a> <span>&#45;&gt;</span> ((<span class="type-var">'req</span>, <span class="type-var">'meth</span>) <a href="RouterState/index.html#type-state">RouterState.state</a> * (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)) option</code></dt><dd><p><code>anything</code> will consume and drop any pathvalue, irrespective of its type.</p></dd></dl><dl><dt class="spec value" id="val-method'"><a href="#val-method'" class="anchor"></a><code><span class="keyword">val</span> method' : <span class="type-var">'meth</span> <span>&#45;&gt;</span> (<span class="type-var">'req</span>, <span class="type-var">'meth</span>) <a href="RouterState/index.html#type-state">RouterState.state</a> <span>&#45;&gt;</span> ((<span class="type-var">'req</span>, <span class="type-var">'meth</span>) <a href="RouterState/index.html#type-state">RouterState.state</a> * (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)) option</code></dt><dd><p><code>method'</code> meth will match on the provided HTTP method of a request.</p></dd></dl><dl><dt class="spec value" id="val-str"><a href="#val-str" class="anchor"></a><code><span class="keyword">val</span> str : (<span class="type-var">'req</span>, <span class="type-var">'meth</span>) <a href="RouterState/index.html#type-state">RouterState.state</a> <span>&#45;&gt;</span> ((<span class="type-var">'req</span>, <span class="type-var">'meth</span>) <a href="RouterState/index.html#type-state">RouterState.state</a> * ((string <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span>)) option</code></dt><dd><p><code>str</code> will match and extract a string value that will be forwarded to the request handler.</p></dd></dl><dl><dt class="spec value" id="val-int"><a href="#val-int" class="anchor"></a><code><span class="keyword">val</span> int : (<span class="type-var">'req</span>, <span class="type-var">'meth</span>) <a href="RouterState/index.html#type-state">RouterState.state</a> <span>&#45;&gt;</span> ((<span class="type-var">'req</span>, <span class="type-var">'meth</span>) <a href="RouterState/index.html#type-state">RouterState.state</a> * ((int <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span>)) option</code></dt><dd><p><code>int</code> will match and extract an integer value that will be forwarded to the request handler.</p></dd></dl><dl><dt class="spec value" id="val-int32"><a href="#val-int32" class="anchor"></a><code><span class="keyword">val</span> int32 : (<span class="type-var">'req</span>, <span class="type-var">'meth</span>) <a href="RouterState/index.html#type-state">RouterState.state</a> <span>&#45;&gt;</span> ((<span class="type-var">'req</span>, <span class="type-var">'meth</span>) <a href="RouterState/index.html#type-state">RouterState.state</a> * ((int32 <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span>)) option</code></dt><dd><p><code>int32</code> will match and extract a 32 bit integer.</p></dd></dl><dl><dt class="spec value" id="val-int64"><a href="#val-int64" class="anchor"></a><code><span class="keyword">val</span> int64 : (<span class="type-var">'req</span>, <span class="type-var">'meth</span>) <a href="RouterState/index.html#type-state">RouterState.state</a> <span>&#45;&gt;</span> ((<span class="type-var">'req</span>, <span class="type-var">'meth</span>) <a href="RouterState/index.html#type-state">RouterState.state</a> * ((int64 <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span>)) option</code></dt><dd><p><code>int64</code> will match and extract a 64 bit integer.</p></dd></dl><dl><dt class="spec value" id="val-boolean"><a href="#val-boolean" class="anchor"></a><code><span class="keyword">val</span> boolean : (<span class="type-var">'req</span>, <span class="type-var">'meth</span>) <a href="RouterState/index.html#type-state">RouterState.state</a> <span>&#45;&gt;</span> ((<span class="type-var">'req</span>, <span class="type-var">'meth</span>) <a href="RouterState/index.html#type-state">RouterState.state</a> * ((bool <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span>)) option</code></dt><dd><p><code>boolean</code> will match and extract a boolean value.</p></dd></dl><dl><dt class="spec value" id="val-(&lt;/&gt;)"><a href="#val-(&lt;/&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;/&gt;) : (<span class="type-var">'req</span> <span>&#45;&gt;</span> (<span class="type-var">'req</span> * (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)) option) <span>&#45;&gt;</span> (<span class="type-var">'req</span> <span>&#45;&gt;</span> (<span class="type-var">'req</span> * (<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)) option) <span>&#45;&gt;</span> <span class="type-var">'req</span> <span>&#45;&gt;</span> (<span class="type-var">'req</span> * (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)) option</code></dt><dd><p><code>&lt;/&gt;</code> is used to connect two path parsers. Ex: str &lt;/&gt; int will first try and parse a string, followed by an integer. If any of the parsers fail, the whole route matching fails.</p></dd></dl><dl><dt class="spec value" id="val-(==&gt;)"><a href="#val-(==&gt;)" class="anchor"></a><code><span class="keyword">val</span> (==&gt;) : ((<span class="type-var">'req</span>, <span class="type-var">'meth</span>) <a href="RouterState/index.html#type-state">RouterState.state</a> <span>&#45;&gt;</span> ((<span class="type-var">'req</span>, <span class="type-var">'meth</span>) <a href="RouterState/index.html#type-state">RouterState.state</a> * (<span class="type-var">'k</span> <span>&#45;&gt;</span> <span class="type-var">'res</span>)) option) <span>&#45;&gt;</span> ((<span class="type-var">'req</span>, <span class="type-var">'meth</span>) <a href="RouterState/index.html#type-state">RouterState.state</a> <span>&#45;&gt;</span> <span class="type-var">'k</span>) <span>&#45;&gt;</span> (<span class="type-var">'req</span>, <span class="type-var">'meth</span>) <a href="RouterState/index.html#type-state">RouterState.state</a> <span>&#45;&gt;</span> <span class="type-var">'res</span> option</code></dt><dd><p><code>==&gt;</code> connects a route matcher to a user provided handler. The provided handler will receive the entire request object, and any other types that were extracted while parsing the route.</p></dd></dl><dl><dt class="spec value" id="val-match'"><a href="#val-match'" class="anchor"></a><code><span class="keyword">val</span> match' : req:<span class="type-var">'req</span> <span>&#45;&gt;</span> target:string <span>&#45;&gt;</span> meth:<span class="type-var">'meth</span> <span>&#45;&gt;</span> (<span class="type-var">'req</span>, <span class="type-var">'res</span>, <span class="type-var">'meth</span>) <a href="index.html#type-route">route</a> list <span>&#45;&gt;</span> <span class="type-var">'res</span> option</code></dt><dd><p><code>match'</code> takes a request, target, method and runs it through a list of route matching patterns. It will stop at the first match.</p></dd></dl><dl><dt class="spec value" id="val-match_with_state"><a href="#val-match_with_state" class="anchor"></a><code><span class="keyword">val</span> match_with_state : state:(<span class="type-var">'req</span>, <span class="type-var">'meth</span>) <a href="RouterState/index.html#type-state">RouterState.state</a> <span>&#45;&gt;</span> (<span class="type-var">'req</span>, <span class="type-var">'res</span>, <span class="type-var">'meth</span>) <a href="index.html#type-route">route</a> list <span>&#45;&gt;</span> <span class="type-var">'res</span> option</code></dt><dd><p><code>match_with_state</code> takes a router state and runs it through a list of routes. This is useful when using handlers that in-turn define their own routes.</p></dd></dl></div></body></html>