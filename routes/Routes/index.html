<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Routes (routes.Routes)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">routes</a> &#x00BB; Routes</nav><h1>Module <code>Routes</code></h1><p>Typed routing for OCaml. <code>Routes</code> provides combinators for adding typed routing to OCaml applications. The core library will be independent of any particular web framework or runtime.</p></header><dl><dt class="spec type" id="type-path"><a href="#type-path" class="anchor"></a><code><span class="keyword">type</span> <span>('a, 'b) path</span></code></dt><dd><p><code>path</code> represents a sequence of path parameter patterns that are expected in a route.</p></dd></dl><dl><dt class="spec type" id="type-target"><a href="#type-target" class="anchor"></a><code><span class="keyword">type</span> <span>('a, 'b) target</span></code></dt><dd><p><code>target</code> represents a combination of a sequence of path params, and whether that sequence should consider trailing slash parameters or not. Its analogous to a URI target.</p><dl><dt>since</dt><dd>0.8.0</dd></dl></dd></dl><dl><dt class="spec type" id="type-route"><a href="#type-route" class="anchor"></a><code><span class="keyword">type</span> <span>'b route</span></code></dt><dd><p><code>route</code> is a combination of a path sequence, with a function that will be called on a successful match. When a path sequence matches, the patterns that are extracted are forwarded to said function with the types that the user defined. Note that because of <a href="https://caml.inria.fr/pub/docs/manual-ocaml/polymorphism.html#ss:valuerestriction">value restriction</a>, the route definitions will be assigned a weak type by the compiler. This causes problems if one intends to re-use the same route definition in multiple contexts, like using a single definition for both matching a target url, and serializing to use in a client call. To avoid such problems one can use eta-expansion (i.e. add an explicit argument to the route definition).</p><p>Example:</p><pre><code class="ml">let route () =
  Routes.(
    (s &quot;foo&quot; / str / int /? nil)
    @--&gt; fun (a : string) (b : int) -&gt; Printf.sprintf &quot;%s %d&quot; a b)
;;</code></pre></dd></dl><dl><dt class="spec type" id="type-router"><a href="#type-router" class="anchor"></a><code><span class="keyword">type</span> <span>'b router</span></code></dt><dd><p><code>router</code> is a collection of multiple routes. It transforms a list of routes into a trie like structure, that is then used for matching an input target url.</p></dd></dl><div class="spec module" id="module-Parts"><a href="#module-Parts" class="anchor"></a><code><span class="keyword">module</span> <a href="Parts/index.html">Parts</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-int"><a href="#val-int" class="anchor"></a><code><span class="keyword">val</span> int : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span><span>(int <span>&#45;&gt;</span> <span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span></code></dt><dd><p><code>int</code> matches a path segment if it can be successfully coerced into an integer.</p></dd></dl><dl><dt class="spec value" id="val-int32"><a href="#val-int32" class="anchor"></a><code><span class="keyword">val</span> int32 : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span><span>(int32 <span>&#45;&gt;</span> <span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span></code></dt><dd><p><code>int32</code> matches a path segment if it can be successfully coerced into a 32 bit integer.</p></dd></dl><dl><dt class="spec value" id="val-int64"><a href="#val-int64" class="anchor"></a><code><span class="keyword">val</span> int64 : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span><span>(int64 <span>&#45;&gt;</span> <span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span></code></dt><dd><p><code>int64</code> matches a path segment if it can be successfully coerced into a 64 bit integer.</p></dd></dl><dl><dt class="spec value" id="val-str"><a href="#val-str" class="anchor"></a><code><span class="keyword">val</span> str : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span><span>(string <span>&#45;&gt;</span> <span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span></code></dt><dd><p><code>str</code> matches any path segment and forwards it as a string.</p></dd></dl><dl><dt class="spec value" id="val-bool"><a href="#val-bool" class="anchor"></a><code><span class="keyword">val</span> bool : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span><span>(bool <span>&#45;&gt;</span> <span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span></code></dt><dd><p><code>bool</code> matches a path segment if it can be successfully coerced into a boolean.</p></dd></dl><dl><dt class="spec value" id="val-s"><a href="#val-s" class="anchor"></a><code><span class="keyword">val</span> s : string <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span></code></dt><dd><p><code>s word</code> matches a path segment if it exactly matches <code>word</code>. The matched path param is then discarded.</p></dd></dl><dl><dt class="spec value" id="val-wildcard"><a href="#val-wildcard" class="anchor"></a><code><span class="keyword">val</span> wildcard : <span><span>(<a href="Parts/index.html#type-t">Parts.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>, <span class="type-var">'a</span>)</span> <a href="index.html#type-path">path</a></span></code></dt><dd><p><code>wildcard</code> matches all remaining path segments as a string.</p></dd></dl><dl><dt class="spec value" id="val-nil"><a href="#val-nil" class="anchor"></a><code><span class="keyword">val</span> nil : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span> <a href="index.html#type-path">path</a></span></code></dt><dd><p><code>nil</code> is used to end a sequence of path parameters.</p></dd></dl><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span> <a href="index.html#type-target">target</a></span></code></dt><dd><p><code>empty</code> is used to represent an empty route. This is useful for matching a route that equals &quot;/&quot; or &quot;&quot;.</p><dl><dt>since</dt><dd>0.8.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-pattern"><a href="#val-pattern" class="anchor"></a><code><span class="keyword">val</span> pattern : <span>(<span class="type-var">'c</span> <span>&#45;&gt;</span> string)</span> <span>&#45;&gt;</span> <span>(string <span>&#45;&gt;</span> <span><span class="type-var">'c</span> option</span>)</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span></code></dt><dd><p><code>pattern</code> accepts two functions, one for converting a user provided type to a string representation, and another to potentially convert a string to the said type. With these two functions, it creates a pattern that can be used for matching a path segment. This is useful when there is a need for types that aren't provided out of the box by the library. It also accepts a string label that will be used when pretty printing the route pattern. it is recommended to use a string value starting with `:` character for the label, example: ':shape', ':float' etc</p><p>Example:</p><pre><code class="ml">type shape =
  | Square
  | Circle

let shape_of_string = function
  | &quot;square&quot; -&gt; Some Square
  | &quot;circle&quot; -&gt; Some Circle
  | _ -&gt; None
;;

let shape_to_string = function
  | Square -&gt; &quot;square&quot;
  | Circle -&gt; &quot;circle&quot;
;;

let shape = Routes.pattern shape_to_string shape_of_string &quot;:shape&quot;

(* Now the shape pattern can be used just like any of the built in patterns like
   int, bool etc *)
let route () = s &quot;shape&quot; / shape / s &quot;create&quot; /? nil</code></pre></dd></dl><dl><dt class="spec value" id="val-custom"><a href="#val-custom" class="anchor"></a><code><span class="keyword">val</span> custom : <span>serialize:<span>(<span class="type-var">'c</span> <span>&#45;&gt;</span> string)</span></span> <span>&#45;&gt;</span> <span>parse:<span>(string <span>&#45;&gt;</span> <span><span class="type-var">'c</span> option</span>)</span></span> <span>&#45;&gt;</span> <span>label:string</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span></code></dt><dd><p><code>custom</code> is a labelled alternative to <code>pattern</code>.</p><p>Example:</p><pre><code class="ml">module Shape = struct
  type t =
    | Square
    | Circle

  let parse = function
    | &quot;square&quot; -&gt; Some Square
    | &quot;circle&quot; -&gt; Some Circle
    | _ -&gt; None
  ;;

  let serialize = function
    | Square -&gt; &quot;square&quot;
    | Circle -&gt; &quot;circle&quot;
  ;;

  let p r = Routes.custom ~serialize ~parse ~label:&quot;:shape&quot; r
end

(* Now the shape pattern can be used just like any of the built in patterns like
   int, bool etc *)
let route () = s &quot;shape&quot; / Shape.p / s &quot;create&quot; /? nil</code></pre><dl><dt>since</dt><dd>0.8.1</dd></dl></dd></dl><dl><dt class="spec value" id="val-(/)"><a href="#val-(/)" class="anchor"></a><code><span class="keyword">val</span> (/) : <span>(<span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'d</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span>)</span> <span>&#45;&gt;</span> <span class="type-var">'d</span> <span>&#45;&gt;</span> <span class="type-var">'c</span></code></dt><dd><p><code>l / r</code> joins two path match patterns <code>l</code> and <code>r</code> into a pattern sequence, parse l followed by parse r. Example: If we want to define a route that matches a string followd by a constant &quot;foo&quot; and then an integer, we'd use the <code>/</code> operator like below:</p><pre><code class="ml">let route () = Routes.(str / s &quot;foo&quot; / int /? nil) </code></pre></dd></dl><dl><dt class="spec value" id="val-(/~)"><a href="#val-(/~)" class="anchor"></a><code><span class="keyword">val</span> (/~) : <span>(<span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <a href="index.html#type-path">path</a></span>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-target">target</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <a href="index.html#type-target">target</a></span></code></dt><dt class="spec value" id="val-(/?)"><a href="#val-(/?)" class="anchor"></a><code><span class="keyword">val</span> (/?) : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'b</span>, <span class="type-var">'c</span>)</span> <a href="index.html#type-path">path</a></span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'b</span>, <span class="type-var">'c</span>)</span> <a href="index.html#type-target">target</a></span></code></dt><dd><p><code>l /? r</code> is used to express the sequence of, parse l followed by parse r and then stop parsing. This is used at the end of the route pattern to define how a route should end. The right hand parameter <code>r</code> should be a pattern definition that cannot be used in further chains joined by <code>/</code>.</p><p><code>/?</code> also indicates that a route needs to finish without a trailing slash.</p></dd></dl><dl><dt class="spec value" id="val-(//?)"><a href="#val-(//?)" class="anchor"></a><code><span class="keyword">val</span> (//?) : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'b</span>, <span class="type-var">'c</span>)</span> <a href="index.html#type-path">path</a></span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'b</span>, <span class="type-var">'c</span>)</span> <a href="index.html#type-target">target</a></span></code></dt><dd><p><code>//?</code> is similar to <code>/?</code> with the difference that it is used to create a route that must finish with a trailing slash.</p><dl><dt>since</dt><dd>0.8.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-(@--&gt;)"><a href="#val-(@--&gt;)" class="anchor"></a><code><span class="keyword">val</span> (@--&gt;) : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-target">target</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-route">route</a></span></code></dt><dd><p><code>r @--&gt; h</code> is used to connect a route pattern <code>r</code> to a function <code>h</code> that gets called if this pattern is successfully matched.</p></dd></dl><dl><dt class="spec value" id="val-one_of"><a href="#val-one_of" class="anchor"></a><code><span class="keyword">val</span> one_of : <span><span><span class="type-var">'b</span> <a href="index.html#type-route">route</a></span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-router">router</a></span></code></dt><dd><p><code>one_of</code> accepts a list of tuples comprised of route definitions of type <code>'b route</code> where 'b is the type that a successful route match will return.</p><p>It transforms the input list of routes into a trie like structure that can later be used to perform route matches.</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-route">route</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-route">route</a></span></code></dt><dt class="spec value" id="val-match'"><a href="#val-match'" class="anchor"></a><code><span class="keyword">val</span> match' : <span><span class="type-var">'a</span> <a href="index.html#type-router">router</a></span> <span>&#45;&gt;</span> <span>target:string</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></dt><dd><p><code>match'</code> accepts a router and the target url to match.</p></dd></dl><dl><dt class="spec value" id="val-ksprintf"><a href="#val-ksprintf" class="anchor"></a><code><span class="keyword">val</span> ksprintf : <span>(string <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-target">target</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>ksprintf</code> takes a route pattern as an input and applies a continuation to the result of formatting the pattern into a URI path.</p></dd></dl><dl><dt class="spec value" id="val-sprintf"><a href="#val-sprintf" class="anchor"></a><code><span class="keyword">val</span> sprintf : <span><span>(<span class="type-var">'a</span>, string)</span> <a href="index.html#type-target">target</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>sprintf</code> takes a route pattern as an input, and returns a string with the result of formatting the pattern into a URI path.</p></dd></dl><dl><dt class="spec value" id="val-pp_target"><a href="#val-pp_target" class="anchor"></a><code><span class="keyword">val</span> pp_target : Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-target">target</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp_target</code> can be used to pretty-print a sequence of path params. This can be useful to get a human readable output that indicates the kind of pattern that a route will match. When creating a custom pattern matcher using <code>pattern</code>, a string label needs to be provided. This label is used by <code>pp_target</code> when preparing the pretty-print output.</p><p>Example:</p><pre><code class="ml">let r () = Routes.(s &quot;foo&quot; / int / s &quot;add&quot; / bool);;
Format.asprintf &quot;%a&quot; Routes.pp_target r;;
-: &quot;foo/:int/add/:bool&quot;</code></pre><dl><dt>since</dt><dd>0.8.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-pp_route"><a href="#val-pp_route" class="anchor"></a><code><span class="keyword">val</span> pp_route : Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-route">route</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp_route</code> is similar to <code>pp_target</code>, except it takes a route (combination of path sequence and a handler) as input, instead of just a path sequence.</p></dd></dl><dl><dt class="spec value" id="val-add_route"><a href="#val-add_route" class="anchor"></a><code><span class="keyword">val</span> add_route : <span><span class="type-var">'b</span> <a href="index.html#type-route">route</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-router">router</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-router">router</a></span></code></dt><dd><p><code>add_route</code> takes a route and a router as input, and returns a new router which contains the route provided as input.</p><dl><dt>since</dt><dd>0.7.3</dd></dl></dd></dl><dl><dt class="spec value" id="val-union"><a href="#val-union" class="anchor"></a><code><span class="keyword">val</span> union : <span><span class="type-var">'a</span> <a href="index.html#type-router">router</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-router">router</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-router">router</a></span></code></dt><dd><p><code>union</code> performs a left-biased merge of two routers.</p></dd></dl></div></body></html>