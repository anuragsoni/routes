<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Routes (routes.Routes)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">routes</a> &#x00BB; Routes</nav><h1>Module <code>Routes</code></h1><p>Typed routing for OCaml. <code>Routes</code> provides combinators for adding typed routing to OCaml applications. The core library will be independent of any particular web framework or runtime.</p></header><dl><dt class="spec type" id="type-path"><a href="#type-path" class="anchor"></a><code><span class="keyword">type</span> <span>('a, 'b) path</span></code></dt><dd><p><code>path</code> represents a sequence of path parameter patterns that are expected in a route.</p></dd></dl><dl><dt class="spec type" id="type-route"><a href="#type-route" class="anchor"></a><code><span class="keyword">type</span> <span>'b route</span></code></dt><dd><p><code>route</code> is a combination of a path sequence, with a function that will be called on a successful match. When a path sequence matches, the patterns that are extracted are forwarded to said function with the types that the user defined. Note that because of <a href="https://caml.inria.fr/pub/docs/manual-ocaml/polymorphism.html#ss:valuerestriction">value restriction</a>, the route definitions will be assigned a weak type by the compiler. This causes problems if one intends to re-use the same route definition in multiple contexts, like using a single definition for both matching a target url, and serializing to use in a client call. To avoid such problems one can use eta-expansion (i.e. add an explicit argument to the route definition).</p><p>Example:</p><pre><code class="ml">let route () = Routes.(s &quot;foo&quot; / str / int /? nil @--&gt;
  (fun (a : string) (b : int) -&gt;
      Printf.sprintf &quot;%s %d&quot; a b))</code></pre></dd></dl><dl><dt class="spec type" id="type-router"><a href="#type-router" class="anchor"></a><code><span class="keyword">type</span> <span>'b router</span></code></dt><dd><p><code>router</code> is a collection of multiple routes. It transforms a list of routes into a trie like structure, that is then used for matching an input target url.</p></dd></dl><dl><dt class="spec value" id="val-int"><a href="#val-int" class="anchor"></a><code><span class="keyword">val</span> int : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span><span>(int <span>&#45;&gt;</span> <span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span></code></dt><dd><p><code>int</code> matches a path segment if it can be successfully coerced into an integer.</p></dd></dl><dl><dt class="spec value" id="val-int32"><a href="#val-int32" class="anchor"></a><code><span class="keyword">val</span> int32 : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span><span>(int32 <span>&#45;&gt;</span> <span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span></code></dt><dd><p><code>int32</code> matches a path segment if it can be successfully coerced into a 32 bit integer.</p></dd></dl><dl><dt class="spec value" id="val-int64"><a href="#val-int64" class="anchor"></a><code><span class="keyword">val</span> int64 : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span><span>(int64 <span>&#45;&gt;</span> <span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span></code></dt><dd><p><code>int64</code> matches a path segment if it can be successfully coerced into a 64 bit integer.</p></dd></dl><dl><dt class="spec value" id="val-str"><a href="#val-str" class="anchor"></a><code><span class="keyword">val</span> str : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span><span>(string <span>&#45;&gt;</span> <span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span></code></dt><dd><p><code>str</code> matches any path segment and forwards it as a string.</p></dd></dl><dl><dt class="spec value" id="val-bool"><a href="#val-bool" class="anchor"></a><code><span class="keyword">val</span> bool : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span><span>(bool <span>&#45;&gt;</span> <span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span></code></dt><dd><p><code>bool</code> matches a path segment if it can be successfully coerced into a boolean.</p></dd></dl><dl><dt class="spec value" id="val-s"><a href="#val-s" class="anchor"></a><code><span class="keyword">val</span> s : string <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span></code></dt><dd><p><code>s word</code> matches a path segment if it exactly matches <code>word</code>. The matched path param is then discarded.</p></dd></dl><dl><dt class="spec value" id="val-nil"><a href="#val-nil" class="anchor"></a><code><span class="keyword">val</span> nil : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span> <a href="index.html#type-path">path</a></span></code></dt><dd><p><code>nil</code> is used at the end of a path pattern sequence to indicate that a route should only match if it ends without a trailing slash. This can also be used to match against the root url '/'.</p></dd></dl><dl><dt class="spec value" id="val-trail"><a href="#val-trail" class="anchor"></a><code><span class="keyword">val</span> trail : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span> <a href="index.html#type-path">path</a></span></code></dt><dd><p><code>trail</code> is used at the end of a path pattern sequence to indicate that a route should only match if it ends with a trailing slash. This should only be used at the end of a route. If a route needs to match the root url '/' please use <code>nil</code> instead.</p></dd></dl><dl><dt class="spec value" id="val-pattern"><a href="#val-pattern" class="anchor"></a><code><span class="keyword">val</span> pattern : <span>(<span class="type-var">'c</span> <span>&#45;&gt;</span> string)</span> <span>&#45;&gt;</span> <span>(string <span>&#45;&gt;</span> <span><span class="type-var">'c</span> option</span>)</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span></code></dt><dd><p><code>pattern</code> accepts two functions, one for converting a user provided type to a string representation, and another to potentially convert a string to the said type. With these two functions, it creates a pattern that can be used for matching a path segment. This is useful when there is a need for types that aren't provided out of the box by the library. It also accepts a string label that will be used when pretty printing the route pattern. it is recommended to use a string value starting with `:` character for the label, example: ':shape', ':float' etc</p><p>Example:</p><pre><code class="ml">type shape =
  | Square
  | Circle

let shape_of_string = function
  | &quot;square&quot; -&gt; Some Square
  | &quot;circle&quot; -&gt; Some Circle
  | _ -&gt; None

let shape_to_string = function
  | Square -&gt; &quot;square&quot;
  | Circle -&gt; &quot;circle&quot;

let shape = Routes.pattern shape_to_string shape_of_string

(* Now the shape pattern can be used just like any
   of the built in patterns like int, bool etc *)
let route () = s &quot;shape&quot; / shape / s &quot;create&quot; /? nil</code></pre></dd></dl><dl><dt class="spec value" id="val-(/)"><a href="#val-(/)" class="anchor"></a><code><span class="keyword">val</span> (/) : <span>(<span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'d</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span>)</span> <span>&#45;&gt;</span> <span class="type-var">'d</span> <span>&#45;&gt;</span> <span class="type-var">'c</span></code></dt><dd><p><code>l / r</code> joins two path match patterns <code>l</code> and <code>r</code> into a pattern sequence, parse l followed by parse r. Example: If we want to define a route that matches a string followd by a constant &quot;foo&quot; and then an integer, we'd use the <code>/</code> operator like below:</p><pre><code class="ml">let route () = Routes.(str / s &quot;foo&quot; / int /? nil)</code></pre></dd></dl><dl><dt class="spec value" id="val-(/?)"><a href="#val-(/?)" class="anchor"></a><code><span class="keyword">val</span> (/?) : <span>(<span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span class="type-var">'c</span></code></dt><dd><p><code>l /? r</code> is used to express the sequence of, parse l followed by parse r and then stop parsing. This is used at the end of the route pattern to define how a route should end. The right hand parameter <code>r</code> should be a pattern definition that cannot be used in further chains joined by <code>/</code> (One such operator is <code>nil</code>).</p></dd></dl><dl><dt class="spec value" id="val-(@--&gt;)"><a href="#val-(@--&gt;)" class="anchor"></a><code><span class="keyword">val</span> (@--&gt;) : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-route">route</a></span></code></dt><dd><p><code>r @--&gt; h</code> is used to connect a route pattern <code>r</code> to a function <code>h</code> that gets called if this pattern is successfully matched.</p></dd></dl><dl><dt class="spec value" id="val-one_of"><a href="#val-one_of" class="anchor"></a><code><span class="keyword">val</span> one_of : <span><span><span class="type-var">'b</span> <a href="index.html#type-route">route</a></span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-router">router</a></span></code></dt><dd><p><code>one_of</code> accepts a list of tuples comprised of route definitions of type <code>'b route</code> where 'b is the type that a successful route match will return.</p><p>It transforms the input list of routes into a trie like structure that can later be used to perform route matches.</p></dd></dl><dl><dt class="spec value" id="val-match'"><a href="#val-match'" class="anchor"></a><code><span class="keyword">val</span> match' : <span><span class="type-var">'a</span> <a href="index.html#type-router">router</a></span> <span>&#45;&gt;</span> <span>target:string</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></dt><dd><p><code>match'</code> accepts a router and the target url to match.</p></dd></dl><dl><dt class="spec value" id="val-sprintf"><a href="#val-sprintf" class="anchor"></a><code><span class="keyword">val</span> sprintf : <span><span>(<span class="type-var">'a</span>, string)</span> <a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>sprintf</code> takes a route pattern as an input, and returns a string with the result of formatting the pattern into a URI path.</p></dd></dl><dl><dt class="spec value" id="val-pp_path"><a href="#val-pp_path" class="anchor"></a><code><span class="keyword">val</span> pp_path : Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp_path</code> can be used to pretty-print a path sequence. This can be useful to get a human readable output that indicates the kind of pattern that a route will match. When creating a custom pattern matcher using <code>pattern</code>, a string label needs to be provided. This label is used by <code>pp_path</code> when preparing the pretty-print output.</p><p>Example:</p><pre><code class="ml">let r () = Routes.(s &quot;foo&quot; / int / s &quot;add&quot; / bool);;
Format.asprintf &quot;%a&quot; Routes.pp_path r;;
-: &quot;foo/:int/add/:bool&quot;</code></pre></dd></dl><dl><dt class="spec value" id="val-pp_route"><a href="#val-pp_route" class="anchor"></a><code><span class="keyword">val</span> pp_route : Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-route">route</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp_route</code> is similar to <code>pp_path</code>, except it takes a route (combination of path sequence and a handler) as input, instead of just a path sequence.</p></dd></dl></div></body></html>