<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Routes (routes.Routes)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">routes</a> &#x00BB; Routes</nav><h1>Module <code>Routes</code></h1><p>Typed routing for OCaml. <code>Routes</code> provides combinators for adding typed routing to OCaml applications. The core library will be independent of any particular web framework or runtime.</p></header><div class="spec module" id="module-Method"><a href="#module-Method" class="anchor"></a><code><span class="keyword">module</span> <a href="Method/index.html">Method</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec type" id="type-path"><a href="#type-path" class="anchor"></a><code><span class="keyword">type</span> <span>('a, 'b) path</span></code></dt><dd><p><code>path</code> represents a sequence of path parameter patterns that are expected in a route.</p></dd></dl><dl><dt class="spec type" id="type-route"><a href="#type-route" class="anchor"></a><code><span class="keyword">type</span> <span>'b route</span></code></dt><dd><p><code>route</code> is a combination of a path sequence, with a function that will be called on a successful match. When a path sequence matches, the patterns that are extracted are forwarded to said function with the types that the user defined.</p><p>Example:</p><pre><code class="ml">let route () = Routes.(s &quot;foo&quot; / str / int /? nil @--&gt;
  (fun (a : string) (b : int) -&gt;
      Printf.sprintf &quot;%s %d&quot; a b))</code></pre></dd></dl><dl><dt class="spec type" id="type-router"><a href="#type-router" class="anchor"></a><code><span class="keyword">type</span> <span>'b router</span></code></dt><dd><p><code>router</code> is a collection of multiple routes. It transforms a list of routes into a trie like structure, that is then used for matching an input target url. It works for routes that are grouped by an HTTP verb and for standalone routes that have no HTTP verb attached to it.</p></dd></dl><dl><dt class="spec value" id="val-int"><a href="#val-int" class="anchor"></a><code><span class="keyword">val</span> int : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span><span>(int <span>&#45;&gt;</span> <span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span></code></dt><dd><p><code>int</code> matches a path segment if it can be successfully coerced into an integer.</p></dd></dl><dl><dt class="spec value" id="val-int32"><a href="#val-int32" class="anchor"></a><code><span class="keyword">val</span> int32 : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span><span>(int32 <span>&#45;&gt;</span> <span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span></code></dt><dd><p><code>int32</code> matches a path segment if it can be successfully coerced into a 32 bit integer.</p></dd></dl><dl><dt class="spec value" id="val-int64"><a href="#val-int64" class="anchor"></a><code><span class="keyword">val</span> int64 : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span><span>(int64 <span>&#45;&gt;</span> <span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span></code></dt><dd><p><code>int64</code> matches a path segment if it can be successfully coerced into a 64 bit integer.</p></dd></dl><dl><dt class="spec value" id="val-str"><a href="#val-str" class="anchor"></a><code><span class="keyword">val</span> str : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span><span>(string <span>&#45;&gt;</span> <span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span></code></dt><dd><p><code>str</code> matches any path segment and forwards it as a string.</p></dd></dl><dl><dt class="spec value" id="val-bool"><a href="#val-bool" class="anchor"></a><code><span class="keyword">val</span> bool : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span><span>(bool <span>&#45;&gt;</span> <span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span></code></dt><dd><p><code>bool</code> matches a path segment if it can be successfully coerced into a boolean.</p></dd></dl><dl><dt class="spec value" id="val-s"><a href="#val-s" class="anchor"></a><code><span class="keyword">val</span> s : string <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span></code></dt><dd><p><code>s word</code> matches a path segment if it exactly matches <code>word</code>. The matched path param is then discarded.</p></dd></dl><dl><dt class="spec value" id="val-nil"><a href="#val-nil" class="anchor"></a><code><span class="keyword">val</span> nil : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span> <a href="index.html#type-path">path</a></span></code></dt><dt class="spec value" id="val-pattern"><a href="#val-pattern" class="anchor"></a><code><span class="keyword">val</span> pattern : <span>(<span class="type-var">'c</span> <span>&#45;&gt;</span> string)</span> <span>&#45;&gt;</span> <span>(string <span>&#45;&gt;</span> <span><span class="type-var">'c</span> option</span>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span></code></dt><dd><p><code>pattern</code> accepts two functions, one for converting a user provided type to a string representation, and another to potentially convert a string to the said type. With these two functions, it creates a pattern that can be used for matching a path segment. This is useful when there is a need for types that aren't provided out of the box by the library.</p><p>Example:</p><pre><code class="ml">type shape =
  | Square
  | Circle

let shape_of_string = function
  | &quot;square&quot; -&gt; Some Square
  | &quot;circle&quot; -&gt; Some Circle
  | _ -&gt; None

let shape_to_string = function
  | Square -&gt; &quot;square&quot;
  | Circle -&gt; &quot;circle&quot;

let shape = Routes.pattern shape_to_string shape_of_string

(* Now the shape pattern can be used just like any
   of the built in patterns like int, bool etc *)
let route () = s &quot;shape&quot; / shape / s &quot;create&quot; /? nil</code></pre></dd></dl><dl><dt class="spec value" id="val-(/)"><a href="#val-(/)" class="anchor"></a><code><span class="keyword">val</span> (/) : <span>(<span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'d</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span>)</span> <span>&#45;&gt;</span> <span class="type-var">'d</span> <span>&#45;&gt;</span> <span class="type-var">'c</span></code></dt><dd><p><code>l / r</code> joins two path match patterns <code>l</code> and <code>r</code> into a pattern sequence, parse l followed by parse r. Example: If we want to define a route that matches a string followd by a constant &quot;foo&quot; and then an integer, we'd use the <code>/</code> operator like below:</p><pre><code class="ml">let route () = Routes.(str / s &quot;foo&quot; / int /? nil)</code></pre></dd></dl><dl><dt class="spec value" id="val-(/?)"><a href="#val-(/?)" class="anchor"></a><code><span class="keyword">val</span> (/?) : <span>(<span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span> <span>&#45;&gt;</span> <span class="type-var">'c</span></code></dt><dd><p><code>l /? r</code> is used to express the sequence of, parse l followed by parse r and then stop parsing. This is used at the end of the route pattern to define how a route should end. The right hand parameter <code>r</code> should be a pattern definition that cannot be used in further chains joined by <code>/</code> (One such operator is <code>nil</code>).</p></dd></dl><dl><dt class="spec value" id="val-(@--&gt;)"><a href="#val-(@--&gt;)" class="anchor"></a><code><span class="keyword">val</span> (@--&gt;) : <span>(unit <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-route">route</a></span></code></dt><dd><p><code>r @--&gt; h</code> is used to connect a route pattern <code>r</code> to a function <code>h</code> that gets called if this pattern is successfully matched.</p></dd></dl><dl><dt class="spec value" id="val-one_of"><a href="#val-one_of" class="anchor"></a><code><span class="keyword">val</span> one_of : <span><span>(<span><a href="Method/index.html#type-t">Method.t</a> option</span> * <span><span class="type-var">'b</span> <a href="index.html#type-route">route</a></span>)</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-router">router</a></span></code></dt><dd><p><code>one_of</code> accepts a list of tuples comprised of an optional HTTP verb and a route definition of type <code>'b route</code> where 'b is the type that a successful route match will return.</p><p>It transforms the input list of routes into a trie like structure that can later be used to perform route matches.</p></dd></dl><dl><dt class="spec value" id="val-match'"><a href="#val-match'" class="anchor"></a><code><span class="keyword">val</span> match' : <span>?&#8288;meth:<a href="Method/index.html#type-t">Method.t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-router">router</a></span> <span>&#45;&gt;</span> <span>target:string</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></dt><dd><p><code>match'</code> accepts an optional HTTP verb, a router and the target url to match. if the HTTP verb is provided, it tries to look for a matching route that was defined with the specific HTTP verb provided as input. Otherwise it looks for a route that is not associated to any HTTP verb.</p></dd></dl><dl><dt class="spec value" id="val-sprintf"><a href="#val-sprintf" class="anchor"></a><code><span class="keyword">val</span> sprintf : <span>(unit <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, string)</span> <a href="index.html#type-path">path</a></span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>sprintf</code> takes a route pattern as an input, and returns a string with the result of formatting the pattern into a URI path.</p></dd></dl><dl><dt class="spec value" id="val-ksprintf"><a href="#val-ksprintf" class="anchor"></a><code><span class="keyword">val</span> ksprintf : <span>(<span>string list</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span>(unit <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-path">path</a></span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>ksprintf</code> is the same as <code>sprintf</code>, but instead of returning a string, it passes it to the function provided as the first argument.</p></dd></dl></div></body></html>