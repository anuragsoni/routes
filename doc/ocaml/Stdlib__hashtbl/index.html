<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Stdlib__hashtbl (ocaml.Stdlib__hashtbl)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">ocaml</a> &#x00BB; Stdlib__hashtbl</nav><h1>Module <code>Stdlib__hashtbl</code></h1><p>Hash tables and hash functions.</p><p>Hash tables are hashed association tables, with in-place modification.</p><nav class="toc"><ul><li><a href="#generic-interface">Generic interface</a></li><li><a href="#iterators">Iterators</a></li><li><a href="#functorial-interface">Functorial interface</a></li><li><a href="#the-polymorphic-hash-functions">The polymorphic hash functions</a></li></ul></nav></header><section><header><h2 id="generic-interface"><a href="#generic-interface" class="anchor"></a>Generic interface</h2></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>('a, 'b) t</span></code></dt><dd><p>The type of hash tables from type <code>'a</code> to type <code>'b</code>.</p></dd></dl><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : <span>?&#8288;random:bool</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>Hashtbl.create n</code> creates a new, empty hash table, with initial size <code>n</code>. For best results, <code>n</code> should be on the order of the expected number of elements that will be in the table. The table grows as needed, so <code>n</code> is just an initial guess.</p><p>The optional <code>random</code> parameter (a boolean) controls whether the internal organization of the hash table is randomized at each execution of <code>Hashtbl.create</code> or deterministic over all executions.</p><p>A hash table that is created with <code>~random:false</code> uses a fixed hash function (<span class="xref-unresolved" title="unresolved reference to &quot;Hashtbl.hash&quot;"><code>Hashtbl</code>.hash</span>) to distribute keys among buckets. As a consequence, collisions between keys happen deterministically. In Web-facing applications or other security-sensitive applications, the deterministic collision patterns can be exploited by a malicious user to create a denial-of-service attack: the attacker sends input crafted to create many collisions in the table, slowing the application down.</p><p>A hash table that is created with <code>~random:true</code> uses the seeded hash function <span class="xref-unresolved" title="unresolved reference to &quot;Hashtbl.seeded_hash&quot;"><code>Hashtbl</code>.seeded_hash</span> with a seed that is randomly chosen at hash table creation time. In effect, the hash function used is randomly selected among <code>2^{30}</code> different hash functions. All these hash functions have different collision patterns, rendering ineffective the denial-of-service attack described above. However, because of randomization, enumerating all elements of the hash table using <span class="xref-unresolved" title="unresolved reference to &quot;Hashtbl.fold&quot;"><code>Hashtbl</code>.fold</span> or <span class="xref-unresolved" title="unresolved reference to &quot;Hashtbl.iter&quot;"><code>Hashtbl</code>.iter</span> is no longer deterministic: elements are enumerated in different orders at different runs of the program.</p><p>If no <code>~random</code> parameter is given, hash tables are created in non-random mode by default. This default can be changed either programmatically by calling <span class="xref-unresolved" title="unresolved reference to &quot;Hashtbl.randomize&quot;"><code>Hashtbl</code>.randomize</span> or by setting the <code>R</code> flag in the <code>OCAMLRUNPARAM</code> environment variable.</p><dl><dt>before 4.00.0</dt><dd><p>the <code>random</code> parameter was not present and all hash tables were created in non-randomized mode.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-clear"><a href="#val-clear" class="anchor"></a><code><span class="keyword">val</span> clear : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Empty a hash table. Use <code>reset</code> instead of <code>clear</code> to shrink the size of the bucket table to its initial size.</p></dd></dl><dl><dt class="spec value" id="val-reset"><a href="#val-reset" class="anchor"></a><code><span class="keyword">val</span> reset : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Empty a hash table and shrink the size of the bucket table to its initial size.</p><dl><dt>since</dt><dd>4.00.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-copy"><a href="#val-copy" class="anchor"></a><code><span class="keyword">val</span> copy : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Return a copy of the given hashtable.</p></dd></dl><dl><dt class="spec value" id="val-add"><a href="#val-add" class="anchor"></a><code><span class="keyword">val</span> add : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>Hashtbl.add tbl x y</code> adds a binding of <code>x</code> to <code>y</code> in table <code>tbl</code>. Previous bindings for <code>x</code> are not removed, but simply hidden. That is, after performing <span class="xref-unresolved" title="unresolved reference to &quot;Hashtbl.remove&quot;"><code>Hashtbl</code>.remove</span><code> tbl x</code>, the previous binding for <code>x</code>, if any, is restored. (Same behavior as with association lists.)</p></dd></dl><dl><dt class="spec value" id="val-find"><a href="#val-find" class="anchor"></a><code><span class="keyword">val</span> find : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p><code>Hashtbl.find tbl x</code> returns the current binding of <code>x</code> in <code>tbl</code>, or raises <code>Not_found</code> if no such binding exists.</p></dd></dl><dl><dt class="spec value" id="val-find_opt"><a href="#val-find_opt" class="anchor"></a><code><span class="keyword">val</span> find_opt : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span></code></dt><dd><p><code>Hashtbl.find_opt tbl x</code> returns the current binding of <code>x</code> in <code>tbl</code>, or <code>None</code> if no such binding exists.</p><dl><dt>since</dt><dd>4.05</dd></dl></dd></dl><dl><dt class="spec value" id="val-find_all"><a href="#val-find_all" class="anchor"></a><code><span class="keyword">val</span> find_all : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span></code></dt><dd><p><code>Hashtbl.find_all tbl x</code> returns the list of all data associated with <code>x</code> in <code>tbl</code>. The current binding is returned first, then the previous bindings, in reverse order of introduction in the table.</p></dd></dl><dl><dt class="spec value" id="val-mem"><a href="#val-mem" class="anchor"></a><code><span class="keyword">val</span> mem : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>Hashtbl.mem tbl x</code> checks if <code>x</code> is bound in <code>tbl</code>.</p></dd></dl><dl><dt class="spec value" id="val-remove"><a href="#val-remove" class="anchor"></a><code><span class="keyword">val</span> remove : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>Hashtbl.remove tbl x</code> removes the current binding of <code>x</code> in <code>tbl</code>, restoring the previous binding if it exists. It does nothing if <code>x</code> is not bound in <code>tbl</code>.</p></dd></dl><dl><dt class="spec value" id="val-replace"><a href="#val-replace" class="anchor"></a><code><span class="keyword">val</span> replace : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>Hashtbl.replace tbl x y</code> replaces the current binding of <code>x</code> in <code>tbl</code> by a binding of <code>x</code> to <code>y</code>. If <code>x</code> is unbound in <code>tbl</code>, a binding of <code>x</code> to <code>y</code> is added to <code>tbl</code>. This is functionally equivalent to <span class="xref-unresolved" title="unresolved reference to &quot;Hashtbl.remove&quot;"><code>Hashtbl</code>.remove</span><code> tbl x</code> followed by <span class="xref-unresolved" title="unresolved reference to &quot;Hashtbl.add&quot;"><code>Hashtbl</code>.add</span><code> tbl x y</code>.</p></dd></dl><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>Hashtbl.iter f tbl</code> applies <code>f</code> to all bindings in table <code>tbl</code>. <code>f</code> receives the key as first argument, and the associated value as second argument. Each binding is presented exactly once to <code>f</code>.</p><p>The order in which the bindings are passed to <code>f</code> is unspecified. However, if the table contains several bindings for the same key, they are passed to <code>f</code> in reverse order of introduction, that is, the most recent binding is passed first.</p><p>If the hash table was created in non-randomized mode, the order in which the bindings are enumerated is reproducible between successive runs of the program, and even between minor versions of OCaml. For randomized hash tables, the order of enumeration is entirely random.</p><p>The behavior is not defined if the hash table is modified by <code>f</code> during the iteration.</p></dd></dl><dl><dt class="spec value" id="val-filter_map_inplace"><a href="#val-filter_map_inplace" class="anchor"></a><code><span class="keyword">val</span> filter_map_inplace : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>Hashtbl.filter_map_inplace f tbl</code> applies <code>f</code> to all bindings in table <code>tbl</code> and update each binding depending on the result of <code>f</code>. If <code>f</code> returns <code>None</code>, the binding is discarded. If it returns <code>Some new_val</code>, the binding is update to associate the key to <code>new_val</code>.</p><p>Other comments for <span class="xref-unresolved" title="unresolved reference to &quot;Hashtbl.iter&quot;"><code>Hashtbl</code>.iter</span> apply as well.</p><dl><dt>since</dt><dd>4.03.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val</span> fold : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'c</span></code></dt><dd><p><code>Hashtbl.fold f tbl init</code> computes <code>(f kN dN ... (f k1 d1 init)...)</code>, where <code>k1 ... kN</code> are the keys of all bindings in <code>tbl</code>, and <code>d1 ... dN</code> are the associated values. Each binding is presented exactly once to <code>f</code>.</p><p>The order in which the bindings are passed to <code>f</code> is unspecified. However, if the table contains several bindings for the same key, they are passed to <code>f</code> in reverse order of introduction, that is, the most recent binding is passed first.</p><p>If the hash table was created in non-randomized mode, the order in which the bindings are enumerated is reproducible between successive runs of the program, and even between minor versions of OCaml. For randomized hash tables, the order of enumeration is entirely random.</p><p>The behavior is not defined if the hash table is modified by <code>f</code> during the iteration.</p></dd></dl><dl><dt class="spec value" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">val</span> length : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int</code></dt><dd><p><code>Hashtbl.length tbl</code> returns the number of bindings in <code>tbl</code>. It takes constant time. Multiple bindings are counted once each, so <code>Hashtbl.length</code> gives the number of times <code>Hashtbl.iter</code> calls its first argument.</p></dd></dl><dl><dt class="spec value" id="val-randomize"><a href="#val-randomize" class="anchor"></a><code><span class="keyword">val</span> randomize : unit <span>&#45;&gt;</span> unit</code></dt><dd><p>After a call to <code>Hashtbl.randomize()</code>, hash tables are created in randomized mode by default: <span class="xref-unresolved" title="unresolved reference to &quot;Hashtbl.create&quot;"><code>Hashtbl</code>.create</span> returns randomized hash tables, unless the <code>~random:false</code> optional parameter is given. The same effect can be achieved by setting the <code>R</code> parameter in the <code>OCAMLRUNPARAM</code> environment variable.</p><p>It is recommended that applications or Web frameworks that need to protect themselves against the denial-of-service attack described in <span class="xref-unresolved" title="unresolved reference to &quot;Hashtbl.create&quot;"><code>Hashtbl</code>.create</span> call <code>Hashtbl.randomize()</code> at initialization time.</p><p>Note that once <code>Hashtbl.randomize()</code> was called, there is no way to revert to the non-randomized default behavior of <span class="xref-unresolved" title="unresolved reference to &quot;Hashtbl.create&quot;"><code>Hashtbl</code>.create</span>. This is intentional. Non-randomized hash tables can still be created using <code>Hashtbl.create ~random:false</code>.</p><dl><dt>since</dt><dd>4.00.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-is_randomized"><a href="#val-is_randomized" class="anchor"></a><code><span class="keyword">val</span> is_randomized : unit <span>&#45;&gt;</span> bool</code></dt><dd><p>return if the tables are currently created in randomized mode by default</p><dl><dt>since</dt><dd>4.03.0</dd></dl></dd></dl><dl><dt class="spec type" id="type-statistics"><a href="#type-statistics" class="anchor"></a><code><span class="keyword">type</span> statistics</code><code> = </code><code>{</code><table class="record"><tr id="type-statistics.num_bindings" class="anchored"><td class="def field"><a href="#type-statistics.num_bindings" class="anchor"></a><code>num_bindings : int;</code></td><td class="doc"><p>Number of bindings present in the table. Same value as returned by <span class="xref-unresolved" title="unresolved reference to &quot;Hashtbl.length&quot;"><code>Hashtbl</code>.length</span>.</p></td></tr><tr id="type-statistics.num_buckets" class="anchored"><td class="def field"><a href="#type-statistics.num_buckets" class="anchor"></a><code>num_buckets : int;</code></td><td class="doc"><p>Number of buckets in the table.</p></td></tr><tr id="type-statistics.max_bucket_length" class="anchored"><td class="def field"><a href="#type-statistics.max_bucket_length" class="anchor"></a><code>max_bucket_length : int;</code></td><td class="doc"><p>Maximal number of bindings per bucket.</p></td></tr><tr id="type-statistics.bucket_histogram" class="anchored"><td class="def field"><a href="#type-statistics.bucket_histogram" class="anchor"></a><code>bucket_histogram : <span>int array</span>;</code></td><td class="doc"><p>Histogram of bucket sizes. This array <code>histo</code> has length <code>max_bucket_length + 1</code>. The value of <code>histo.(i)</code> is the number of buckets whose size is <code>i</code>.</p></td></tr></table><code>}</code></dt><dd><dl><dt>since</dt><dd>4.00.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-stats"><a href="#val-stats" class="anchor"></a><code><span class="keyword">val</span> stats : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-statistics">statistics</a></code></dt><dd><p><code>Hashtbl.stats tbl</code> returns statistics about the table <code>tbl</code>: number of buckets, size of the biggest bucket, distribution of buckets by size.</p><dl><dt>since</dt><dd>4.00.0</dd></dl></dd></dl></section><section><header><h2 id="iterators"><a href="#iterators" class="anchor"></a>Iterators</h2></header><dl><dt class="spec value" id="val-to_seq"><a href="#val-to_seq" class="anchor"></a><code><span class="keyword">val</span> to_seq : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="../Stdlib/Seq/index.html#type-t">Stdlib.Seq.t</a></span></code></dt><dd><p>Iterate on the whole table. The order in which the bindings appear in the sequence is unspecified. However, if the table contains several bindings for the same key, they appear in reversed order of introduction, that is, the most recent binding appears first.</p><p>The behavior is not defined if the hash table is modified during the iteration.</p><dl><dt>since</dt><dd>4.07</dd></dl></dd></dl><dl><dt class="spec value" id="val-to_seq_keys"><a href="#val-to_seq_keys" class="anchor"></a><code><span class="keyword">val</span> to_seq_keys : <span><span>(<span class="type-var">'a</span>, <span class="type-var">_</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../Stdlib/Seq/index.html#type-t">Stdlib.Seq.t</a></span></code></dt><dd><p>Same as <code>Seq.map fst (to_seq m)</code></p><dl><dt>since</dt><dd>4.07</dd></dl></dd></dl><dl><dt class="spec value" id="val-to_seq_values"><a href="#val-to_seq_values" class="anchor"></a><code><span class="keyword">val</span> to_seq_values : <span><span>(<span class="type-var">_</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="../Stdlib/Seq/index.html#type-t">Stdlib.Seq.t</a></span></code></dt><dd><p>Same as <code>Seq.map snd (to_seq m)</code></p><dl><dt>since</dt><dd>4.07</dd></dl></dd></dl><dl><dt class="spec value" id="val-add_seq"><a href="#val-add_seq" class="anchor"></a><code><span class="keyword">val</span> add_seq : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="../Stdlib/Seq/index.html#type-t">Stdlib.Seq.t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Add the given bindings to the table, using <a href="index.html#val-add"><code>add</code></a></p><dl><dt>since</dt><dd>4.07</dd></dl></dd></dl><dl><dt class="spec value" id="val-replace_seq"><a href="#val-replace_seq" class="anchor"></a><code><span class="keyword">val</span> replace_seq : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="../Stdlib/Seq/index.html#type-t">Stdlib.Seq.t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Add the given bindings to the table, using <a href="index.html#val-replace"><code>replace</code></a></p><dl><dt>since</dt><dd>4.07</dd></dl></dd></dl><dl><dt class="spec value" id="val-of_seq"><a href="#val-of_seq" class="anchor"></a><code><span class="keyword">val</span> of_seq : <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="../Stdlib/Seq/index.html#type-t">Stdlib.Seq.t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Build a table from the given bindings. The bindings are added in the same order they appear in the sequence, using <a href="index.html#val-replace_seq"><code>replace_seq</code></a>, which means that if two pairs have the same key, only the latest one will appear in the table.</p><dl><dt>since</dt><dd>4.07</dd></dl></dd></dl></section><section><header><h2 id="functorial-interface"><a href="#functorial-interface" class="anchor"></a>Functorial interface</h2></header><aside><p>The functorial interface allows the use of specific comparison and hash functions, either for performance/security concerns, or because keys are not hashable/comparable with the polymorphic builtins.</p><p>For instance, one might want to specialize a table for integer keys:</p><pre><code class="ml">module IntHash =
  struct
    type t = int
    let equal i j = i=j
    let hash i = i land max_int
  end

module IntHashtbl = Hashtbl.Make(IntHash)

let h = IntHashtbl.create 17 in
IntHashtbl.add h 12 &quot;hello&quot;</code></pre><p>This creates a new module <code>IntHashtbl</code>, with a new type <code>'a
    IntHashtbl.t</code> of tables from <code>int</code> to <code>'a</code>. In this example, <code>h</code> contains <code>string</code> values so its type is <code>string IntHashtbl.t</code>.</p><p>Note that the new type <code>'a IntHashtbl.t</code> is not compatible with the type <code>('a,'b) Hashtbl.t</code> of the generic interface. For example, <code>Hashtbl.length h</code> would not type-check, you must use <code>IntHashtbl.length</code>.</p></aside><dl><dt class="spec module-type" id="module-type-HashedType"><a href="#module-type-HashedType" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-HashedType/index.html">HashedType</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The input signature of the functor <span class="xref-unresolved" title="unresolved reference to &quot;Hashtbl.Make&quot;"><code>Hashtbl</code>.Make</span>.</p></dd></dl><dl><dt class="spec module-type" id="module-type-S"><a href="#module-type-S" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-S/index.html">S</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The output signature of the functor <span class="xref-unresolved" title="unresolved reference to &quot;Hashtbl.Make&quot;"><code>Hashtbl</code>.Make</span>.</p></dd></dl><dl><dt class="spec module" id="module-Make"><a href="#module-Make" class="anchor"></a><code><span class="keyword">module</span> <a href="Make/index.html">Make</a> : <span class="keyword">functor</span> (<a href="Make/argument-1-H/index.html">H</a> : <a href="index.html#module-type-HashedType">HashedType</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-S">S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Make/index.html#type-key">key</a> = <a href="Make/argument-1-H/index.html#type-t">H.t</a></code></dt><dd><p>Functor building an implementation of the hashtable structure. The functor <code>Hashtbl.Make</code> returns a structure containing a type <code>key</code> of keys and a type <code>'a t</code> of hash tables associating data of type <code>'a</code> to keys of type <code>key</code>. The operations perform similarly to those of the generic interface, but use the hashing and equality functions specified in the functor argument <code>H</code> instead of generic equality and hashing. Since the hash function is not seeded, the <code>create</code> operation of the result structure always returns non-randomized hash tables.</p></dd></dl><dl><dt class="spec module-type" id="module-type-SeededHashedType"><a href="#module-type-SeededHashedType" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-SeededHashedType/index.html">SeededHashedType</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The input signature of the functor <span class="xref-unresolved" title="unresolved reference to &quot;Hashtbl.MakeSeeded&quot;"><code>Hashtbl</code>.MakeSeeded</span>.</p></dd></dl><dl><dt class="spec module-type" id="module-type-SeededS"><a href="#module-type-SeededS" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-SeededS/index.html">SeededS</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>The output signature of the functor <span class="xref-unresolved" title="unresolved reference to &quot;Hashtbl.MakeSeeded&quot;"><code>Hashtbl</code>.MakeSeeded</span>.</p></dd></dl><dl><dt class="spec module" id="module-MakeSeeded"><a href="#module-MakeSeeded" class="anchor"></a><code><span class="keyword">module</span> <a href="MakeSeeded/index.html">MakeSeeded</a> : <span class="keyword">functor</span> (<a href="MakeSeeded/argument-1-H/index.html">H</a> : <a href="index.html#module-type-SeededHashedType">SeededHashedType</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-SeededS">SeededS</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="MakeSeeded/index.html#type-key">key</a> = <a href="MakeSeeded/argument-1-H/index.html#type-t">H.t</a></code></dt><dd><p>Functor building an implementation of the hashtable structure. The functor <code>Hashtbl.MakeSeeded</code> returns a structure containing a type <code>key</code> of keys and a type <code>'a t</code> of hash tables associating data of type <code>'a</code> to keys of type <code>key</code>. The operations perform similarly to those of the generic interface, but use the seeded hashing and equality functions specified in the functor argument <code>H</code> instead of generic equality and hashing. The <code>create</code> operation of the result structure supports the <code>~random</code> optional parameter and returns randomized hash tables if <code>~random:true</code> is passed or if randomization is globally on (see <span class="xref-unresolved" title="unresolved reference to &quot;Hashtbl.randomize&quot;"><code>Hashtbl</code>.randomize</span>).</p></dd></dl></section><section><header><h2 id="the-polymorphic-hash-functions"><a href="#the-polymorphic-hash-functions" class="anchor"></a>The polymorphic hash functions</h2></header><dl><dt class="spec value" id="val-hash"><a href="#val-hash" class="anchor"></a><code><span class="keyword">val</span> hash : <span class="type-var">'a</span> <span>&#45;&gt;</span> int</code></dt><dd><p><code>Hashtbl.hash x</code> associates a nonnegative integer to any value of any type. It is guaranteed that if <code>x = y</code> or <code>Stdlib.compare x y = 0</code>, then <code>hash x = hash y</code>. Moreover, <code>hash</code> always terminates, even on cyclic structures.</p></dd></dl><dl><dt class="spec value" id="val-seeded_hash"><a href="#val-seeded_hash" class="anchor"></a><code><span class="keyword">val</span> seeded_hash : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int</code></dt><dd><p>A variant of <span class="xref-unresolved" title="unresolved reference to &quot;Hashtbl.hash&quot;"><code>Hashtbl</code>.hash</span> that is further parameterized by an integer seed.</p><dl><dt>since</dt><dd>4.00.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-hash_param"><a href="#val-hash_param" class="anchor"></a><code><span class="keyword">val</span> hash_param : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int</code></dt><dd><p><code>Hashtbl.hash_param meaningful total x</code> computes a hash value for <code>x</code>, with the same properties as for <code>hash</code>. The two extra integer parameters <code>meaningful</code> and <code>total</code> give more precise control over hashing. Hashing performs a breadth-first, left-to-right traversal of the structure <code>x</code>, stopping after <code>meaningful</code> meaningful nodes were encountered, or <code>total</code> nodes (meaningful or not) were encountered. If <code>total</code> as specified by the user exceeds a certain value, currently 256, then it is capped to that value. Meaningful nodes are: integers; floating-point numbers; strings; characters; booleans; and constant constructors. Larger values of <code>meaningful</code> and <code>total</code> means that more nodes are taken into account to compute the final hash value, and therefore collisions are less likely to happen. However, hashing takes longer. The parameters <code>meaningful</code> and <code>total</code> govern the tradeoff between accuracy and speed. As default choices, <span class="xref-unresolved" title="unresolved reference to &quot;Hashtbl.hash&quot;"><code>Hashtbl</code>.hash</span> and <span class="xref-unresolved" title="unresolved reference to &quot;Hashtbl.seeded_hash&quot;"><code>Hashtbl</code>.seeded_hash</span> take <code>meaningful = 10</code> and <code>total = 100</code>.</p></dd></dl><dl><dt class="spec value" id="val-seeded_hash_param"><a href="#val-seeded_hash_param" class="anchor"></a><code><span class="keyword">val</span> seeded_hash_param : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int</code></dt><dd><p>A variant of <span class="xref-unresolved" title="unresolved reference to &quot;Hashtbl.hash_param&quot;"><code>Hashtbl</code>.hash_param</span> that is further parameterized by an integer seed. Usage: <code>Hashtbl.seeded_hash_param meaningful total seed x</code>.</p><dl><dt>since</dt><dd>4.00.0</dd></dl></dd></dl></section></div></body></html>