<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>BytesLabels (ocaml.Stdlib.BytesLabels)</title><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">ocaml</a> &#x00BB; <a href="../index.html">Stdlib</a> &#x00BB; BytesLabels</nav><h1>Module <code>Stdlib.BytesLabels</code></h1><nav class="toc"><ul><li><a href="#iterators">Iterators</a></li><li><a href="#binary-encoding/decoding-of-integers">Binary encoding/decoding of integers</a></li></ul></nav></header><aside><p>Byte sequence operations.</p><dl><dt>since</dt><dd>4.02.0</dd></dl></aside><dl><dt class="spec external" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">val</span> length : bytes <span>&#45;&gt;</span> int</code></dt><dd><p>Return the length (number of bytes) of the argument.</p></dd></dl><dl><dt class="spec external" id="val-get"><a href="#val-get" class="anchor"></a><code><span class="keyword">val</span> get : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char</code></dt><dd><p><code>get s n</code> returns the byte at index <code>n</code> in argument <code>s</code>.</p><p>Raise <code>Invalid_argument</code> if <code>n</code> is not a valid index in <code>s</code>.</p></dd></dl><dl><dt class="spec external" id="val-set"><a href="#val-set" class="anchor"></a><code><span class="keyword">val</span> set : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> unit</code></dt><dd><p><code>set s n c</code> modifies <code>s</code> in place, replacing the byte at index <code>n</code> with <code>c</code>.</p><p>Raise <code>Invalid_argument</code> if <code>n</code> is not a valid index in <code>s</code>.</p></dd></dl><dl><dt class="spec external" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : int <span>&#45;&gt;</span> bytes</code></dt><dd><p><code>create n</code> returns a new byte sequence of length <code>n</code>. The sequence is uninitialized and contains arbitrary bytes.</p><p>Raise <code>Invalid_argument</code> if <code>n &lt; 0</code> or <code>n &gt; </code><a href="../Sys/index.html#val-max_string_length"><code>Sys.max_string_length</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">val</span> make : int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> bytes</code></dt><dd><p><code>make n c</code> returns a new byte sequence of length <code>n</code>, filled with the byte <code>c</code>.</p><p>Raise <code>Invalid_argument</code> if <code>n &lt; 0</code> or <code>n &gt; </code><a href="../Sys/index.html#val-max_string_length"><code>Sys.max_string_length</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-init"><a href="#val-init" class="anchor"></a><code><span class="keyword">val</span> init : int <span>&#45;&gt;</span> <span>f:<span>(int <span>&#45;&gt;</span> char)</span></span> <span>&#45;&gt;</span> bytes</code></dt><dd><p><code>init n f</code> returns a fresh byte sequence of length <code>n</code>, with character <code>i</code> initialized to the result of <code>f i</code>.</p><p>Raise <code>Invalid_argument</code> if <code>n &lt; 0</code> or <code>n &gt; </code><a href="../Sys/index.html#val-max_string_length"><code>Sys.max_string_length</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : bytes</code></dt><dd><p>A byte sequence of size 0.</p></dd></dl><dl><dt class="spec value" id="val-copy"><a href="#val-copy" class="anchor"></a><code><span class="keyword">val</span> copy : bytes <span>&#45;&gt;</span> bytes</code></dt><dd><p>Return a new byte sequence that contains the same bytes as the argument.</p></dd></dl><dl><dt class="spec value" id="val-of_string"><a href="#val-of_string" class="anchor"></a><code><span class="keyword">val</span> of_string : string <span>&#45;&gt;</span> bytes</code></dt><dd><p>Return a new byte sequence that contains the same bytes as the given string.</p></dd></dl><dl><dt class="spec value" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val</span> to_string : bytes <span>&#45;&gt;</span> string</code></dt><dd><p>Return a new string that contains the same bytes as the given byte sequence.</p></dd></dl><dl><dt class="spec value" id="val-sub"><a href="#val-sub" class="anchor"></a><code><span class="keyword">val</span> sub : bytes <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> <span>len:int</span> <span>&#45;&gt;</span> bytes</code></dt><dd><p><code>sub s start len</code> returns a new byte sequence of length <code>len</code>, containing the subsequence of <code>s</code> that starts at position <code>start</code> and has length <code>len</code>.</p><p>Raise <code>Invalid_argument</code> if <code>start</code> and <code>len</code> do not designate a valid range of <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-sub_string"><a href="#val-sub_string" class="anchor"></a><code><span class="keyword">val</span> sub_string : bytes <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> <span>len:int</span> <span>&#45;&gt;</span> string</code></dt><dd><p>Same as <code>sub</code> but return a string instead of a byte sequence.</p></dd></dl><dl><dt class="spec value" id="val-extend"><a href="#val-extend" class="anchor"></a><code><span class="keyword">val</span> extend : bytes <span>&#45;&gt;</span> <span>left:int</span> <span>&#45;&gt;</span> <span>right:int</span> <span>&#45;&gt;</span> bytes</code></dt><dd><p><code>extend s left right</code> returns a new byte sequence that contains the bytes of <code>s</code>, with <code>left</code> uninitialized bytes prepended and <code>right</code> uninitialized bytes appended to it. If <code>left</code> or <code>right</code> is negative, then bytes are removed (instead of appended) from the corresponding side of <code>s</code>.</p><p>Raise <code>Invalid_argument</code> if the result length is negative or longer than <a href="../Sys/index.html#val-max_string_length"><code>Sys.max_string_length</code></a> bytes.</p><dl><dt>since</dt><dd>4.05.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-fill"><a href="#val-fill" class="anchor"></a><code><span class="keyword">val</span> fill : bytes <span>&#45;&gt;</span> <span>pos:int</span> <span>&#45;&gt;</span> <span>len:int</span> <span>&#45;&gt;</span> char <span>&#45;&gt;</span> unit</code></dt><dd><p><code>fill s start len c</code> modifies <code>s</code> in place, replacing <code>len</code> characters with <code>c</code>, starting at <code>start</code>.</p><p>Raise <code>Invalid_argument</code> if <code>start</code> and <code>len</code> do not designate a valid range of <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-blit"><a href="#val-blit" class="anchor"></a><code><span class="keyword">val</span> blit : <span>src:bytes</span> <span>&#45;&gt;</span> <span>src_pos:int</span> <span>&#45;&gt;</span> <span>dst:bytes</span> <span>&#45;&gt;</span> <span>dst_pos:int</span> <span>&#45;&gt;</span> <span>len:int</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>blit src srcoff dst dstoff len</code> copies <code>len</code> bytes from sequence <code>src</code>, starting at index <code>srcoff</code>, to sequence <code>dst</code>, starting at index <code>dstoff</code>. It works correctly even if <code>src</code> and <code>dst</code> are the same byte sequence, and the source and destination intervals overlap.</p><p>Raise <code>Invalid_argument</code> if <code>srcoff</code> and <code>len</code> do not designate a valid range of <code>src</code>, or if <code>dstoff</code> and <code>len</code> do not designate a valid range of <code>dst</code>.</p></dd></dl><dl><dt class="spec value" id="val-blit_string"><a href="#val-blit_string" class="anchor"></a><code><span class="keyword">val</span> blit_string : <span>src:string</span> <span>&#45;&gt;</span> <span>src_pos:int</span> <span>&#45;&gt;</span> <span>dst:bytes</span> <span>&#45;&gt;</span> <span>dst_pos:int</span> <span>&#45;&gt;</span> <span>len:int</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>blit src srcoff dst dstoff len</code> copies <code>len</code> bytes from string <code>src</code>, starting at index <code>srcoff</code>, to byte sequence <code>dst</code>, starting at index <code>dstoff</code>.</p><p>Raise <code>Invalid_argument</code> if <code>srcoff</code> and <code>len</code> do not designate a valid range of <code>src</code>, or if <code>dstoff</code> and <code>len</code> do not designate a valid range of <code>dst</code>.</p><dl><dt>since</dt><dd>4.05.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-concat"><a href="#val-concat" class="anchor"></a><code><span class="keyword">val</span> concat : <span>sep:bytes</span> <span>&#45;&gt;</span> <span>bytes list</span> <span>&#45;&gt;</span> bytes</code></dt><dd><p><code>concat sep sl</code> concatenates the list of byte sequences <code>sl</code>, inserting the separator byte sequence <code>sep</code> between each, and returns the result as a new byte sequence.</p></dd></dl><dl><dt class="spec value" id="val-cat"><a href="#val-cat" class="anchor"></a><code><span class="keyword">val</span> cat : bytes <span>&#45;&gt;</span> bytes <span>&#45;&gt;</span> bytes</code></dt><dd><p><code>cat s1 s2</code> concatenates <code>s1</code> and <code>s2</code> and returns the result as new byte sequence.</p><p>Raise <code>Invalid_argument</code> if the result is longer than <a href="../Sys/index.html#val-max_string_length"><code>Sys.max_string_length</code></a> bytes.</p><dl><dt>since</dt><dd>4.05.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : <span>f:<span>(char <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> bytes <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iter f s</code> applies function <code>f</code> in turn to all the bytes of <code>s</code>. It is equivalent to <code>f (get s 0); f (get s 1); ...; f (get s
    (length s - 1)); ()</code>.</p></dd></dl><dl><dt class="spec value" id="val-iteri"><a href="#val-iteri" class="anchor"></a><code><span class="keyword">val</span> iteri : <span>f:<span>(int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> bytes <span>&#45;&gt;</span> unit</code></dt><dd><p>Same as <a href="../Bytes/index.html#val-iter"><code>Bytes.iter</code></a>, but the function is applied to the index of the byte as first argument and the byte itself as second argument.</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span>f:<span>(char <span>&#45;&gt;</span> char)</span></span> <span>&#45;&gt;</span> bytes <span>&#45;&gt;</span> bytes</code></dt><dd><p><code>map f s</code> applies function <code>f</code> in turn to all the bytes of <code>s</code> and stores the resulting bytes in a new sequence that is returned as the result.</p></dd></dl><dl><dt class="spec value" id="val-mapi"><a href="#val-mapi" class="anchor"></a><code><span class="keyword">val</span> mapi : <span>f:<span>(int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> char)</span></span> <span>&#45;&gt;</span> bytes <span>&#45;&gt;</span> bytes</code></dt><dd><p><code>mapi f s</code> calls <code>f</code> with each character of <code>s</code> and its index (in increasing index order) and stores the resulting bytes in a new sequence that is returned as the result.</p></dd></dl><dl><dt class="spec value" id="val-trim"><a href="#val-trim" class="anchor"></a><code><span class="keyword">val</span> trim : bytes <span>&#45;&gt;</span> bytes</code></dt><dd><p>Return a copy of the argument, without leading and trailing whitespace. The bytes regarded as whitespace are the ASCII characters <code>' '</code>, <code>'\012'</code>, <code>'\n'</code>, <code>'\r'</code>, and <code>'\t'</code>.</p></dd></dl><dl><dt class="spec value" id="val-escaped"><a href="#val-escaped" class="anchor"></a><code><span class="keyword">val</span> escaped : bytes <span>&#45;&gt;</span> bytes</code></dt><dd><p>Return a copy of the argument, with special characters represented by escape sequences, following the lexical conventions of OCaml.</p></dd></dl><dl><dt class="spec value" id="val-index"><a href="#val-index" class="anchor"></a><code><span class="keyword">val</span> index : bytes <span>&#45;&gt;</span> char <span>&#45;&gt;</span> int</code></dt><dd><p><code>index s c</code> returns the index of the first occurrence of byte <code>c</code> in <code>s</code>.</p><p>Raise <code>Not_found</code> if <code>c</code> does not occur in <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-index_opt"><a href="#val-index_opt" class="anchor"></a><code><span class="keyword">val</span> index_opt : bytes <span>&#45;&gt;</span> char <span>&#45;&gt;</span> <span>int option</span></code></dt><dd><p><code>index_opt s c</code> returns the index of the first occurrence of byte <code>c</code> in <code>s</code> or <code>None</code> if <code>c</code> does not occur in <code>s</code>.</p><dl><dt>since</dt><dd>4.05</dd></dl></dd></dl><dl><dt class="spec value" id="val-rindex"><a href="#val-rindex" class="anchor"></a><code><span class="keyword">val</span> rindex : bytes <span>&#45;&gt;</span> char <span>&#45;&gt;</span> int</code></dt><dd><p><code>rindex s c</code> returns the index of the last occurrence of byte <code>c</code> in <code>s</code>.</p><p>Raise <code>Not_found</code> if <code>c</code> does not occur in <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-rindex_opt"><a href="#val-rindex_opt" class="anchor"></a><code><span class="keyword">val</span> rindex_opt : bytes <span>&#45;&gt;</span> char <span>&#45;&gt;</span> <span>int option</span></code></dt><dd><p><code>rindex_opt s c</code> returns the index of the last occurrence of byte <code>c</code> in <code>s</code> or <code>None</code> if <code>c</code> does not occur in <code>s</code>.</p><dl><dt>since</dt><dd>4.05</dd></dl></dd></dl><dl><dt class="spec value" id="val-index_from"><a href="#val-index_from" class="anchor"></a><code><span class="keyword">val</span> index_from : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> int</code></dt><dd><p><code>index_from s i c</code> returns the index of the first occurrence of byte <code>c</code> in <code>s</code> after position <code>i</code>. <code>Bytes.index s c</code> is equivalent to <code>Bytes.index_from s 0 c</code>.</p><p>Raise <code>Invalid_argument</code> if <code>i</code> is not a valid position in <code>s</code>. Raise <code>Not_found</code> if <code>c</code> does not occur in <code>s</code> after position <code>i</code>.</p></dd></dl><dl><dt class="spec value" id="val-index_from_opt"><a href="#val-index_from_opt" class="anchor"></a><code><span class="keyword">val</span> index_from_opt : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> <span>int option</span></code></dt><dd><p><code>index_from _opts i c</code> returns the index of the first occurrence of byte <code>c</code> in <code>s</code> after position <code>i</code> or <code>None</code> if <code>c</code> does not occur in <code>s</code> after position <code>i</code>. <code>Bytes.index_opt s c</code> is equivalent to <code>Bytes.index_from_opt s 0 c</code>.</p><p>Raise <code>Invalid_argument</code> if <code>i</code> is not a valid position in <code>s</code>.</p><dl><dt>since</dt><dd>4.05</dd></dl></dd></dl><dl><dt class="spec value" id="val-rindex_from"><a href="#val-rindex_from" class="anchor"></a><code><span class="keyword">val</span> rindex_from : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> int</code></dt><dd><p><code>rindex_from s i c</code> returns the index of the last occurrence of byte <code>c</code> in <code>s</code> before position <code>i+1</code>. <code>rindex s c</code> is equivalent to <code>rindex_from s (Bytes.length s - 1) c</code>.</p><p>Raise <code>Invalid_argument</code> if <code>i+1</code> is not a valid position in <code>s</code>. Raise <code>Not_found</code> if <code>c</code> does not occur in <code>s</code> before position <code>i+1</code>.</p></dd></dl><dl><dt class="spec value" id="val-rindex_from_opt"><a href="#val-rindex_from_opt" class="anchor"></a><code><span class="keyword">val</span> rindex_from_opt : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> <span>int option</span></code></dt><dd><p><code>rindex_from_opt s i c</code> returns the index of the last occurrence of byte <code>c</code> in <code>s</code> before position <code>i+1</code> or <code>None</code> if <code>c</code> does not occur in <code>s</code> before position <code>i+1</code>. <code>rindex_opt s c</code> is equivalent to <code>rindex_from s (Bytes.length s - 1) c</code>.</p><p>Raise <code>Invalid_argument</code> if <code>i+1</code> is not a valid position in <code>s</code>.</p><dl><dt>since</dt><dd>4.05</dd></dl></dd></dl><dl><dt class="spec value" id="val-contains"><a href="#val-contains" class="anchor"></a><code><span class="keyword">val</span> contains : bytes <span>&#45;&gt;</span> char <span>&#45;&gt;</span> bool</code></dt><dd><p><code>contains s c</code> tests if byte <code>c</code> appears in <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-contains_from"><a href="#val-contains_from" class="anchor"></a><code><span class="keyword">val</span> contains_from : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> bool</code></dt><dd><p><code>contains_from s start c</code> tests if byte <code>c</code> appears in <code>s</code> after position <code>start</code>. <code>contains s c</code> is equivalent to <code>contains_from
    s 0 c</code>.</p><p>Raise <code>Invalid_argument</code> if <code>start</code> is not a valid position in <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-rcontains_from"><a href="#val-rcontains_from" class="anchor"></a><code><span class="keyword">val</span> rcontains_from : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> bool</code></dt><dd><p><code>rcontains_from s stop c</code> tests if byte <code>c</code> appears in <code>s</code> before position <code>stop+1</code>.</p><p>Raise <code>Invalid_argument</code> if <code>stop &lt; 0</code> or <code>stop+1</code> is not a valid position in <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-uppercase"><a href="#val-uppercase" class="anchor"></a><code><span class="keyword">val</span> uppercase : bytes <span>&#45;&gt;</span> bytes</code></dt><dd><p>Return a copy of the argument, with all lowercase letters translated to uppercase, including accented letters of the ISO Latin-1 (8859-1) character set.</p><dl><dt>deprecated</dt><dd><p>Functions operating on Latin-1 character set are deprecated.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-lowercase"><a href="#val-lowercase" class="anchor"></a><code><span class="keyword">val</span> lowercase : bytes <span>&#45;&gt;</span> bytes</code></dt><dd><p>Return a copy of the argument, with all uppercase letters translated to lowercase, including accented letters of the ISO Latin-1 (8859-1) character set.</p><dl><dt>deprecated</dt><dd><p>Functions operating on Latin-1 character set are deprecated.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-capitalize"><a href="#val-capitalize" class="anchor"></a><code><span class="keyword">val</span> capitalize : bytes <span>&#45;&gt;</span> bytes</code></dt><dd><p>Return a copy of the argument, with the first character set to uppercase, using the ISO Latin-1 (8859-1) character set..</p><dl><dt>deprecated</dt><dd><p>Functions operating on Latin-1 character set are deprecated.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-uncapitalize"><a href="#val-uncapitalize" class="anchor"></a><code><span class="keyword">val</span> uncapitalize : bytes <span>&#45;&gt;</span> bytes</code></dt><dd><p>Return a copy of the argument, with the first character set to lowercase, using the ISO Latin-1 (8859-1) character set..</p><dl><dt>deprecated</dt><dd><p>Functions operating on Latin-1 character set are deprecated.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-uppercase_ascii"><a href="#val-uppercase_ascii" class="anchor"></a><code><span class="keyword">val</span> uppercase_ascii : bytes <span>&#45;&gt;</span> bytes</code></dt><dd><p>Return a copy of the argument, with all lowercase letters translated to uppercase, using the US-ASCII character set.</p><dl><dt>since</dt><dd>4.05.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-lowercase_ascii"><a href="#val-lowercase_ascii" class="anchor"></a><code><span class="keyword">val</span> lowercase_ascii : bytes <span>&#45;&gt;</span> bytes</code></dt><dd><p>Return a copy of the argument, with all uppercase letters translated to lowercase, using the US-ASCII character set.</p><dl><dt>since</dt><dd>4.05.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-capitalize_ascii"><a href="#val-capitalize_ascii" class="anchor"></a><code><span class="keyword">val</span> capitalize_ascii : bytes <span>&#45;&gt;</span> bytes</code></dt><dd><p>Return a copy of the argument, with the first character set to uppercase, using the US-ASCII character set.</p><dl><dt>since</dt><dd>4.05.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-uncapitalize_ascii"><a href="#val-uncapitalize_ascii" class="anchor"></a><code><span class="keyword">val</span> uncapitalize_ascii : bytes <span>&#45;&gt;</span> bytes</code></dt><dd><p>Return a copy of the argument, with the first character set to lowercase, using the US-ASCII character set.</p><dl><dt>since</dt><dd>4.05.0</dd></dl></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = bytes</code></dt><dd><p>An alias for the type of byte sequences.</p></dd></dl><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>The comparison function for byte sequences, with the same specification as <a href="../index.html#val-compare"><code>Stdlib.compare</code></a>. Along with the type <code>t</code>, this function <code>compare</code> allows the module <code>Bytes</code> to be passed as argument to the functors <a href="../Set/Make/index.html"><code>Set.Make</code></a> and <a href="../Map/Make/index.html"><code>Map.Make</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>The equality function for byte sequences.</p><dl><dt>since</dt><dd>4.05.0</dd></dl></dd></dl><section><header><h2 id="iterators"><a href="#iterators" class="anchor"></a>Iterators</h2></header><dl><dt class="spec value" id="val-to_seq"><a href="#val-to_seq" class="anchor"></a><code><span class="keyword">val</span> to_seq : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>char <a href="../Seq/index.html#type-t">Stdlib.Seq.t</a></span></code></dt><dd><p>Iterate on the string, in increasing index order. Modifications of the string during iteration will be reflected in the iterator.</p><dl><dt>since</dt><dd>4.07</dd></dl></dd></dl><dl><dt class="spec value" id="val-to_seqi"><a href="#val-to_seqi" class="anchor"></a><code><span class="keyword">val</span> to_seqi : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span>(int * char)</span> <a href="../Seq/index.html#type-t">Stdlib.Seq.t</a></span></code></dt><dd><p>Iterate on the string, in increasing order, yielding indices along chars</p><dl><dt>since</dt><dd>4.07</dd></dl></dd></dl><dl><dt class="spec value" id="val-of_seq"><a href="#val-of_seq" class="anchor"></a><code><span class="keyword">val</span> of_seq : <span>char <a href="../Seq/index.html#type-t">Stdlib.Seq.t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Create a string from the generator</p><dl><dt>since</dt><dd>4.07</dd></dl></dd></dl></section><section><header><h2 id="binary-encoding/decoding-of-integers"><a href="#binary-encoding/decoding-of-integers" class="anchor"></a>Binary encoding/decoding of integers</h2></header><aside><p>The functions in this section binary encode and decode integers to and from byte sequences.</p><p>All following functions raise <code>Invalid_argument</code> if the space needed at index <code>i</code> to decode or encode the integer is not available.</p><p>Little-endian (resp. big-endian) encoding means that least (resp. most) significant bytes are stored first. Big-endian is also known as network byte order. Native-endian encoding is either little-endian or big-endian depending on <a href="../Sys/index.html#val-big_endian"><code>Sys.big_endian</code></a>.</p><p>32-bit and 64-bit integers are represented by the <code>int32</code> and <code>int64</code> types, which can be interpreted either as signed or unsigned numbers.</p><p>8-bit and 16-bit integers are represented by the <code>int</code> type, which has more bits than the binary encoding. These extra bits are handled as follows: </p><ul><li>Functions that decode signed (resp. unsigned) 8-bit or 16-bit integers represented by <code>int</code> values sign-extend (resp. zero-extend) their result.</li><li>Functions that encode 8-bit or 16-bit integers represented by <code>int</code> values truncate their input to their least significant bytes.</li></ul></aside><dl><dt class="spec value" id="val-get_uint8"><a href="#val-get_uint8" class="anchor"></a><code><span class="keyword">val</span> get_uint8 : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dd><p><code>get_uint8 b i</code> is <code>b</code>'s unsigned 8-bit integer starting at byte index <code>i</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></dd></dl><dl><dt class="spec value" id="val-get_int8"><a href="#val-get_int8" class="anchor"></a><code><span class="keyword">val</span> get_int8 : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dd><p><code>get_int8 b i</code> is <code>b</code>'s signed 8-bit integer starting at byte index <code>i</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></dd></dl><dl><dt class="spec value" id="val-get_uint16_ne"><a href="#val-get_uint16_ne" class="anchor"></a><code><span class="keyword">val</span> get_uint16_ne : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dd><p><code>get_uint16_ne b i</code> is <code>b</code>'s native-endian unsigned 16-bit integer starting at byte index <code>i</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></dd></dl><dl><dt class="spec value" id="val-get_uint16_be"><a href="#val-get_uint16_be" class="anchor"></a><code><span class="keyword">val</span> get_uint16_be : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dd><p><code>get_uint16_be b i</code> is <code>b</code>'s big-endian unsigned 16-bit integer starting at byte index <code>i</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></dd></dl><dl><dt class="spec value" id="val-get_uint16_le"><a href="#val-get_uint16_le" class="anchor"></a><code><span class="keyword">val</span> get_uint16_le : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dd><p><code>get_uint16_le b i</code> is <code>b</code>'s little-endian unsigned 16-bit integer starting at byte index <code>i</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></dd></dl><dl><dt class="spec value" id="val-get_int16_ne"><a href="#val-get_int16_ne" class="anchor"></a><code><span class="keyword">val</span> get_int16_ne : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dd><p><code>get_int16_ne b i</code> is <code>b</code>'s native-endian signed 16-bit integer starting at byte index <code>i</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></dd></dl><dl><dt class="spec value" id="val-get_int16_be"><a href="#val-get_int16_be" class="anchor"></a><code><span class="keyword">val</span> get_int16_be : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dd><p><code>get_int16_be b i</code> is <code>b</code>'s big-endian signed 16-bit integer starting at byte index <code>i</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></dd></dl><dl><dt class="spec value" id="val-get_int16_le"><a href="#val-get_int16_le" class="anchor"></a><code><span class="keyword">val</span> get_int16_le : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dd><p><code>get_int16_le b i</code> is <code>b</code>'s little-endian signed 16-bit integer starting at byte index <code>i</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></dd></dl><dl><dt class="spec value" id="val-get_int32_ne"><a href="#val-get_int32_ne" class="anchor"></a><code><span class="keyword">val</span> get_int32_ne : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int32</code></dt><dd><p><code>get_int32_ne b i</code> is <code>b</code>'s native-endian 32-bit integer starting at byte index <code>i</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></dd></dl><dl><dt class="spec value" id="val-get_int32_be"><a href="#val-get_int32_be" class="anchor"></a><code><span class="keyword">val</span> get_int32_be : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int32</code></dt><dd><p><code>get_int32_be b i</code> is <code>b</code>'s big-endian 32-bit integer starting at byte index <code>i</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></dd></dl><dl><dt class="spec value" id="val-get_int32_le"><a href="#val-get_int32_le" class="anchor"></a><code><span class="keyword">val</span> get_int32_le : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int32</code></dt><dd><p><code>get_int32_le b i</code> is <code>b</code>'s little-endian 32-bit integer starting at byte index <code>i</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></dd></dl><dl><dt class="spec value" id="val-get_int64_ne"><a href="#val-get_int64_ne" class="anchor"></a><code><span class="keyword">val</span> get_int64_ne : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int64</code></dt><dd><p><code>get_int64_ne b i</code> is <code>b</code>'s native-endian 64-bit integer starting at byte index <code>i</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></dd></dl><dl><dt class="spec value" id="val-get_int64_be"><a href="#val-get_int64_be" class="anchor"></a><code><span class="keyword">val</span> get_int64_be : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int64</code></dt><dd><p><code>get_int64_be b i</code> is <code>b</code>'s big-endian 64-bit integer starting at byte index <code>i</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></dd></dl><dl><dt class="spec value" id="val-get_int64_le"><a href="#val-get_int64_le" class="anchor"></a><code><span class="keyword">val</span> get_int64_le : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int64</code></dt><dd><p><code>get_int64_le b i</code> is <code>b</code>'s little-endian 64-bit integer starting at byte index <code>i</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></dd></dl><dl><dt class="spec value" id="val-set_uint8"><a href="#val-set_uint8" class="anchor"></a><code><span class="keyword">val</span> set_uint8 : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p><code>set_uint8 b i v</code> sets <code>b</code>'s unsigned 8-bit integer starting at byte index <code>i</code> to <code>v</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></dd></dl><dl><dt class="spec value" id="val-set_int8"><a href="#val-set_int8" class="anchor"></a><code><span class="keyword">val</span> set_int8 : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p><code>set_int8 b i v</code> sets <code>b</code>'s signed 8-bit integer starting at byte index <code>i</code> to <code>v</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></dd></dl><dl><dt class="spec value" id="val-set_uint16_ne"><a href="#val-set_uint16_ne" class="anchor"></a><code><span class="keyword">val</span> set_uint16_ne : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p><code>set_uint16_ne b i v</code> sets <code>b</code>'s native-endian unsigned 16-bit integer starting at byte index <code>i</code> to <code>v</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></dd></dl><dl><dt class="spec value" id="val-set_uint16_be"><a href="#val-set_uint16_be" class="anchor"></a><code><span class="keyword">val</span> set_uint16_be : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p><code>set_uint16_be b i v</code> sets <code>b</code>'s big-endian unsigned 16-bit integer starting at byte index <code>i</code> to <code>v</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></dd></dl><dl><dt class="spec value" id="val-set_uint16_le"><a href="#val-set_uint16_le" class="anchor"></a><code><span class="keyword">val</span> set_uint16_le : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p><code>set_uint16_le b i v</code> sets <code>b</code>'s little-endian unsigned 16-bit integer starting at byte index <code>i</code> to <code>v</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></dd></dl><dl><dt class="spec value" id="val-set_int16_ne"><a href="#val-set_int16_ne" class="anchor"></a><code><span class="keyword">val</span> set_int16_ne : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p><code>set_int16_ne b i v</code> sets <code>b</code>'s native-endian signed 16-bit integer starting at byte index <code>i</code> to <code>v</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></dd></dl><dl><dt class="spec value" id="val-set_int16_be"><a href="#val-set_int16_be" class="anchor"></a><code><span class="keyword">val</span> set_int16_be : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p><code>set_int16_be b i v</code> sets <code>b</code>'s big-endian signed 16-bit integer starting at byte index <code>i</code> to <code>v</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></dd></dl><dl><dt class="spec value" id="val-set_int16_le"><a href="#val-set_int16_le" class="anchor"></a><code><span class="keyword">val</span> set_int16_le : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p><code>set_int16_le b i v</code> sets <code>b</code>'s little-endian signed 16-bit integer starting at byte index <code>i</code> to <code>v</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></dd></dl><dl><dt class="spec value" id="val-set_int32_ne"><a href="#val-set_int32_ne" class="anchor"></a><code><span class="keyword">val</span> set_int32_ne : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int32 <span>&#45;&gt;</span> unit</code></dt><dd><p><code>set_int32_ne b i v</code> sets <code>b</code>'s native-endian 32-bit integer starting at byte index <code>i</code> to <code>v</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></dd></dl><dl><dt class="spec value" id="val-set_int32_be"><a href="#val-set_int32_be" class="anchor"></a><code><span class="keyword">val</span> set_int32_be : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int32 <span>&#45;&gt;</span> unit</code></dt><dd><p><code>set_int32_be b i v</code> sets <code>b</code>'s big-endian 32-bit integer starting at byte index <code>i</code> to <code>v</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></dd></dl><dl><dt class="spec value" id="val-set_int32_le"><a href="#val-set_int32_le" class="anchor"></a><code><span class="keyword">val</span> set_int32_le : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int32 <span>&#45;&gt;</span> unit</code></dt><dd><p><code>set_int32_le b i v</code> sets <code>b</code>'s little-endian 32-bit integer starting at byte index <code>i</code> to <code>v</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></dd></dl><dl><dt class="spec value" id="val-set_int64_ne"><a href="#val-set_int64_ne" class="anchor"></a><code><span class="keyword">val</span> set_int64_ne : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int64 <span>&#45;&gt;</span> unit</code></dt><dd><p><code>set_int64_ne b i v</code> sets <code>b</code>'s native-endian 64-bit integer starting at byte index <code>i</code> to <code>v</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></dd></dl><dl><dt class="spec value" id="val-set_int64_be"><a href="#val-set_int64_be" class="anchor"></a><code><span class="keyword">val</span> set_int64_be : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int64 <span>&#45;&gt;</span> unit</code></dt><dd><p><code>set_int64_be b i v</code> sets <code>b</code>'s big-endian 64-bit integer starting at byte index <code>i</code> to <code>v</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></dd></dl><dl><dt class="spec value" id="val-set_int64_le"><a href="#val-set_int64_le" class="anchor"></a><code><span class="keyword">val</span> set_int64_le : bytes <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int64 <span>&#45;&gt;</span> unit</code></dt><dd><p><code>set_int64_le b i v</code> sets <code>b</code>'s little-endian 64-bit integer starting at byte index <code>i</code> to <code>v</code>.</p><dl><dt>since</dt><dd>4.08</dd></dl></dd></dl></section></div></body></html>